1                                                          The SAS System                                14:29 Monday, April 9, 2018

NOTE: Unable to open SASUSER.REGSTRY. WORK.REGSTRY will be opened instead.
NOTE: All registry changes will be lost at the end of the session.

WARNING: Unable to copy SASUSER registry to WORK registry. Because of this, you will not see registry customizations during this 
         session.
NOTE: Unable to open SASUSER.PROFILE. WORK.PROFILE will be opened instead.
NOTE: All profile changes will be lost at the end of the session.
NOTE: Copyright (c) 2016 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) Proprietary Software 9.4 (TS1M5) 
      Licensed to 17W47 FCST, Site 70068128.
NOTE: This session is executing on the X64_10PRO  platform.



NOTE: Updated analytical products:
      
      SAS/STAT 14.3
      SAS/ETS 14.3
      SAS/OR 14.3
      SAS/IML 14.3
      SAS/QC 14.3

NOTE: Additional host information:

 X64_10PRO WIN 10.0.16299  Workstation

NOTE: SAS initialization used:
      real time           0.32 seconds
      cpu time            0.23 seconds
      

NOTE: AUTOEXEC processing beginning; file is 
      U:\dev\mva-d4fwc141\fswbsrvr\misc\autoexec_dev.sas.

MPRINT(DCC_AUTOEXEC_DEV):   filename suppress 
"U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work/suppresslog.log";
MPRINT(DCC_AUTOEXEC_DEV):   * get playpen_path;
MPRINT(DCC_AUTOEXEC_DEV):   proc printto log=suppress print=suppress;
MPRINT(DCC_AUTOEXEC_DEV):   quit;

NOTE: PROCEDURE PRINTTO used (Total process time):
      real time           0.00 seconds
2                                       The SAS System              14:29 Monday, April 9, 2018

      cpu time            0.00 seconds
      

MPRINT(DCC_AUTOEXEC_DEV):   * reinitializing the output log to the default location;
MPRINT(DCC_AUTO_SASAUTOS):   proc printto log=suppress print=suppress;
MPRINT(DCC_AUTO_SASAUTOS):   quit;

NOTE: PROCEDURE PRINTTO used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(DCC_AUTO_SASAUTOS):   * reinitializing the output log to the default location;
MPRINT(DCC_AUTO_SASAUTOS):   option mautosource;
MPRINT(DCC_AUTO_SASAUTOS):   options 
sasautos=("run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/dc" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/class" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/cluster" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/vg" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/job" 
"run_unit_tests.bat\..\..\../fswbsrvr/ucmacros/en/util" 
"run_unit_tests.bat\..\..\../fswbsrvr/dev_tools" 
"run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/ucmacros/tst" SASAUTOS );
MPRINT(DCC_AUTOEXEC_DEV):  ;

NOTE: AUTOEXEC processing completed.

1          %include
1        ! "run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/ucmacros/tst/run_unit_test.sas";
267        %run_unit_test(test=%sysget(dc_test),test_output_path=%str(.));
MPRINT(RUN_UNIT_TEST):   options noxwait xsync;
MPRINT(RUN_UNIT_TEST):   * define test output path;
MPRINT(RUN_UNIT_TEST_PUT):   filename res "./custom_interval/run1.txt";
MPRINT(RUN_UNIT_TEST_PUT):   data _null_;
MPRINT(RUN_UNIT_TEST_PUT):   file res;
MPRINT(RUN_UNIT_TEST_PUT):   put "TEST=custom_interval/run1";
MPRINT(RUN_UNIT_TEST_PUT):   run;

NOTE: The file RES is:
      Filename=U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1.txt,
3                                       The SAS System              14:29 Monday, April 9, 2018

      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=09Apr2018:14:29:08,
      Create Time=09Apr2018:14:29:07

NOTE: 1 record was written to the file RES.
      The minimum record length was 25.
      The maximum record length was 25.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   * get email, expects and outputs;
MPRINT(RUN_UNIT_TEST):   data _null_;
MPRINT(RUN_UNIT_TEST):   file 
"U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work/run.sas" lrecl=32767;
MPRINT(RUN_UNIT_TEST):   infile 
"run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/custom_interval/run1.sas" lrecl=32767;
MPRINT(RUN_UNIT_TEST):   format line $32767.;
MPRINT(RUN_UNIT_TEST):   format msg $32767.;
MPRINT(RUN_UNIT_TEST):   format in_comment 1.0;
MPRINT(RUN_UNIT_TEST):   retain in_comment;
MPRINT(RUN_UNIT_TEST):   if (_N_ =1) then do;
MPRINT(RUN_UNIT_TEST):   in_comment = 0;
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   input;
MPRINT(RUN_UNIT_TEST):   line = trim(left(_infile_));
MPRINT(RUN_UNIT_TEST):   i=index(line,'@email');
MPRINT(RUN_UNIT_TEST):   if(i > 0) then do;
MPRINT(RUN_UNIT_TEST):   call symput ('email', compress(substr(line,i+6)));
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   i=index(line,'@expect');
MPRINT(RUN_UNIT_TEST):   if(i > 0) then do;
MPRINT(RUN_UNIT_TEST):   call symput ('expects', trim(left(substr(line,i+7))));
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   if (line = '*/') then do;
MPRINT(RUN_UNIT_TEST):   in_comment = 0;
MPRINT(RUN_UNIT_TEST):   line = '/* */';
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   if (in_comment) then do;
MPRINT(RUN_UNIT_TEST):   if (index(line,'*') = 1) then do;
MPRINT(RUN_UNIT_TEST):   msg = trim(substr(line,3));
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, "%", "%%");
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, '(', '%(');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, ')', '%)');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, '"', '%"');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, "'", "%'");
MPRINT(RUN_UNIT_TEST):   line = cat('%tst_log(msg=%str(',trim(msg),'));');
MPRINT(RUN_UNIT_TEST):   end;
4                                       The SAS System              14:29 Monday, April 9, 2018

MPRINT(RUN_UNIT_TEST):   else do;
MPRINT(RUN_UNIT_TEST):   line = cat('/* ',trim(line),' */');
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   else do;
MPRINT(RUN_UNIT_TEST):   if (index(line,'**') = 1) then do;
MPRINT(RUN_UNIT_TEST):   line = substr(line,1,length(line)-1);
MPRINT(RUN_UNIT_TEST):   msg = trim(substr(line,4));
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, "%", "%%");
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, '(', '%(');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, ')', '%)');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, '"', '%"');
MPRINT(RUN_UNIT_TEST):   msg = tranwrd(msg, "'", "%'");
MPRINT(RUN_UNIT_TEST):   line = cat('%tst_log(msg=%str(',trim(msg),'));');
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   if (line = '/**') then do;
MPRINT(RUN_UNIT_TEST):   if (in_comment = 1) then do;
MPRINT(RUN_UNIT_TEST):   put 'ERROR: encountered /** while looking for */';
MPRINT(RUN_UNIT_TEST):   abort;
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   in_comment = 1;
MPRINT(RUN_UNIT_TEST):   line = '/* */';
MPRINT(RUN_UNIT_TEST):   end;
MPRINT(RUN_UNIT_TEST):   put line;
MPRINT(RUN_UNIT_TEST):   run;

NOTE: The file "U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work/run.sas" is:
      Filename=U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work\run.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=09Apr2018:14:29:08,
      Create Time=09Apr2018:14:29:08

NOTE: The infile "run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/custom_interval/run1.sas" is:
      Filename=U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=5763,
      Last Modified=27Aug2015:13:22:08,
      Create Time=09Apr2018:14:27:59

NOTE: 175 records were written to the file 
      "U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work/run.sas".
      The minimum record length was 1.
      The maximum record length was 127.
NOTE: 175 records were read from the infile 
      "run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/custom_interval/run1.sas".
      The minimum record length was 0.
      The maximum record length was 113.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
5                                       The SAS System              14:29 Monday, April 9, 2018

      

MPRINT(RUN_UNIT_TEST_PUT):   data _null_;
MPRINT(RUN_UNIT_TEST_PUT):   file res mod;
MPRINT(RUN_UNIT_TEST_PUT):   put "EMAIL=yue.li@sas.com";
MPRINT(RUN_UNIT_TEST_PUT):   run;

NOTE: The file RES is:
      Filename=U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1.txt,
      RECFM=V,LRECL=32767,File Size (bytes)=27,
      Last Modified=09Apr2018:14:29:08,
      Create Time=09Apr2018:14:29:07

NOTE: 1 record was written to the file RES.
      The minimum record length was 20.
      The maximum record length was 20.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.00 seconds
      

UNIT_TESTS: EMAIL=yue.li@sas.com
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   * only create .out file if there are no expects;
MPRINT(RUN_UNIT_TEST):   * assuming textual via .out/.exp file;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   * run the test;
MPRINT(RUN_UNIT_TEST):   option LRECL=32767;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   libname test "\\missrv01\f_public\custom_interval\testData";
NOTE: Libref TEST was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: \\missrv01\f_public\custom_interval\testData
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   proc lua restart;
MPRINT(RUN_UNIT_TEST):   submit;
MPRINT(RUN_UNIT_TEST):   run;
6                                       The SAS System              14:29 Monday, April 9, 2018


NOTE: Lua initialized.
Starting Forecasting with Automatic Custom Interval Identification...
    
        libname _ciTmp 
"U:/dev/mva-d4fwc141/fswbsrvr/unit_tests/custom_interval/run1_work/_ci_temp";    
        
1                                       The SAS System              14:29 Monday, April 9, 2018

NOTE: Libref _CITMP was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: U:\dev\mva-d4fwc141\fswbsrvr\unit_tests\custom_interval\run1_work\_ci_temp
        data _NULL_;
           call symputx('ciSeasonality', INTSEAS("WEEK"));
        run;
        
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

        data _ciTmp.inDataNoMiss;
          set test.easter_toy_baskets;
          if TOTAL_ADJ_SALES_AMT ne .;
        run;
        proc sort data=_ciTmp.inDataNoMiss; by EOW_DATE; run;
        proc timeid data=_ciTmp.inDataNoMiss outinterval=_ciTmp.intSum;
           id EOW_DATE;
        run;
        data _ciTmp.intSum;
          set _ciTmp.intSum;
          call symputx('ciInDataStart', start);
          call symputx('ciInDataEnd', end);
        run;
        
NOTE: There were 194 observations read from the data set TEST.EASTER_TOY_BASKETS.
NOTE: The data set _CITMP.INDATANOMISS has 194 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.01 seconds
      

NOTE: There were 194 observations read from the data set _CITMP.INDATANOMISS.
NOTE: The data set _CITMP.INDATANOMISS has 194 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.07 seconds
      cpu time            0.01 seconds
      

NOTE: Number of time vectors processed: 1
NOTE: There were 194 observations read from the data set _CITMP.INDATANOMISS.
NOTE: The data set _CITMP.INTSUM has 1 observations and 24 variables.
NOTE: PROCEDURE TIMEID used (Total process time):
      real time           0.07 seconds
      cpu time            0.01 seconds
      

NOTE: There were 1 observations read from the data set _CITMP.INTSUM.
NOTE: The data set _CITMP.INTSUM has 1 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

        data _NULL_;
           call symputx("local_date", cats("'",put(17690, date9.),"'","d"));
        run;
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

        data _NULL_;
           call symputx("local_date", cats("'",put(19041, date9.),"'","d"));
        run;
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

WARNING: [CUSTOM_INTERVAL_INPUT_PREP component]  The event definition is not specified in 
         either eventDefList or eventDefData. use the default event list (VALENTINES EASTER 
         HALLOWEEN CHRISTMAS) instead.
********INPUT ARGUMENT VALUE INTO CI_FORECAST_RUN:********

localArgs=    table: 000000000BF218E0=
{
  ["zeroDemandThreshold"]=0
  ["idForecastMethod"]="ACCUMULATE"
  ["zeroDemandThresholdPct"]=0.005
  ["forecastCriterion"]="MSE"
  ["processLib"]="_ciTmp"
  ["end"]="'18FEB2012'd"
  ["eventDefBufferLen"]=0
  ["idVar"]="EOW_DATE"
  ["byVars"]=""
  ["demandVar"]="TOTAL_ADJ_SALES_AMT"
  ["debug"]=1
  ["offSeasonRule"]="MEAN"
  ["tempPath"]="U:/dev/mva-d4fwc141/fswbsrvr/unit_tests/custom_interval/run1_work/_ci_temp"
  ["eventIdentifyFlag"]=1
  ["idForecastMode"]="AVG"
7                                       The SAS System              14:29 Monday, April 9, 2018

  ["segMaxError"]=""
  ["patterGroupByVars"]=""
  ["idForecastAccumulate"]="TOTAL"
  ["inSeasonRule"]="MEAN"
  ["setmissing"]=0
  ["eventDefList"]="VALENTINES EASTER HALLOWEEN CHRISTMAS"
  ["runGrouping"]=0
  ["ltsMinDemandCycLen"]=39
  ["seasonIndexData"]=""
  ["sign"]="MIXED"
  ["keepTmp"]=1
  ["idInterval"]="WEEK"
  ["eventPeriodLenThreshold"]=9
  ["outModel"]="work.outModel1"
  ["seasonIndexVar"]=""
  ["allFcstByVars"]=""
  ["cmpLib"]="_ciTmp.ciFuncs"
  ["segMaxPctError"]=""
  ["inData"]="test.easter_toy_baskets"
  ["start"]="'07JUN2008'd"
  ["accumulate"]="TOTAL"
  ["align"]="E"
  ["gapPeriodThreshold"]=13
  ["lead"]=0
  ["outFor"]="work.outFor1"
  ["seasonality"]=52
}
    
      options linesize=max;    
      ods listing close;    
      ods html close;    
    
      proc sort data=test.easter_toy_baskets; by  EOW_DATE; run;
      proc timedata data=test.easter_toy_baskets outarray=_ciTmp.inDataAligned  lead=0;
        ;
        id EOW_DATE interval=WEEK accumulate=TOTAL setmissing=0 align=E start='07JUN2008'd 
end='18FEB2012'd;
        var TOTAL_ADJ_SALES_AMT /setmissing=missing;
        outarrays _season_index;
        do i=1 to dim(EOW_DATE);
          _season_index[i]=_SEASON_[i];
        end;
      run;
      data _ciTmp.inDataFiltered;
        set _ciTmp.inDataAligned;
        if EOW_DATE>='07JUN2008'd and EOW_DATE<='18FEB2012'd;
       run;
    
2                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

NOTE: There are 194 time periods between START=Saturday and END=Saturday.
NOTE: Number of BY groups processed: 1
NOTE: Number of series processed: 1
NOTE: Number of arrays processed: 1
NOTE: There were 194 observations read from the data set TEST.EASTER_TOY_BASKETS.
NOTE: The data set _CITMP.INDATAALIGNED has 194 observations and 7 variables.
NOTE: The data set WORK.DATA1 has 194 observations and 2 variables.
NOTE: PROCEDURE TIMEDATA used (Total process time):
      real time           0.34 seconds
      cpu time            0.09 seconds
      

NOTE: There were 194 observations read from the data set _CITMP.INDATAALIGNED.
NOTE: The data set _CITMP.INDATAFILTERED has 194 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

  %macro ci_fcmp_functions(cmpLib=work.ciFuncs);
      %if not %sysfunc(exist(&cmpLib)) %then %do;
8                                       The SAS System              14:29 Monday, April 9, 2018

      
          proc fcmp ENCRYPT HIDE outlib=&cmpLib..funcs; 
          
          
          
/**********************************************************************************************
*************
              API:
                          ci_compute_sum(timedata[*], sum, count);
              Type:
                          Subroutine
              Purpose: 
                          compute the summation of the elements of the time series array and 
count the total number of non-missing elements
              Input:   
                          timedata[*] : time series array 
                          
              Output: 
                          sum         : the summation of the non-missing elements
                          count       : count of the total number of non-missing elements
          
***********************************************************************************************
************/
              subroutine ci_compute_sum(timedata[*], sum, count);
                  outargs sum, count;
                  sum = .;
                  count=0;
                  length=dim(timedata);
                  if length>0 then do;
                      sum=0;
                      do i=1 to length;
                          if timedata[i] ne . then do;
                              sum = sum + timedata[i];
                              count = count+1;
                          end;
                      end;
                      if count=0 then sum=.;
                  end;
              endsub;
          
/**********************************************************************************************
*************
              API:
                          ci_compute_mean(timedata[*], mean, count);
              Type:
                          Subroutine
              Purpose: 
                          compute the mean of the time series array
              Input:   
                          timedata[*] : time series array 
9                                       The SAS System              14:29 Monday, April 9, 2018

              Output: 
                          sum            : the mean of the non-missing elements
                          count          : count of the total number of non-missing elements
          
***********************************************************************************************
************/
              subroutine ci_compute_mean(timedata[*], mean, count);
                  outargs mean, count;
                  mean = .;
                  count=0;
                  length=dim(timedata);
                  if length>0 then do;
                      call ci_compute_sum(timedata, sum, count);
                      if count>0 and sum ne . then mean = sum / count;
                  end;
              endsub;
          
          
/**********************************************************************************************
*************
              API:
                          ci_compute_order_stats(timedata[*], min, median, max);
              Type:
                          Subroutine
              Purpose: 
                          compute the min, median and max of the non-missing elements of the 
time series array 
              Input:   
                          timedata[*] : time series array 
              Output: 
                          min         : float value as the mininum of the obervations
                          median      : float value as the median of the obervations
                          max         : float value as the maxinum of the obervations
          
          
***********************************************************************************************
************/
              subroutine ci_compute_order_stats(timedata[*], min, median, max);
                  outargs min, median, max;
                  array order[1]/NOSYMBOLS;
                  min = .;
                  median = .;
                  max = .;
                  length=dim(timedata);
                  if length>0 then do;
                      /*sort the array by ascending order*/
                      call dynamic_array(order, length);
                      count=0;
                      do i=1 to length;
                          if timedata[i] ne . then do;
10                                      The SAS System              14:29 Monday, April 9, 2018

                              count = count+1;
                              order[count]=timedata[i];
                          end;
                      end;
                      if count>0 then do;
                          if count=1 then do;
                              min = order[1];
                              median = order[1];
                              max = order[1];
                          end;
                          else do;  /*case count > 1*/
                              do i=1 to count-1;
                                  do j=1 to count-1;
                                      if order[j]>order[j+1] then do;
                                          temp = order[j];
                                          order[j]=order[j+1];
                                          order[j+1]=temp;
                                      end;
                                  end;
                              end;
                              min=order[1];
                              max=order[count];
                              index=floor(count/2);
                              if index*2<count then median = order[index+1];
                              else median = (order[index]+order[index+1])/2;
                          end;
                      end;
                  end;
              endsub;
              
          
/**********************************************************************************************
*************
              API:
                          ci_compute_basic_freq(timedata[*], count, min, median, max, mean, 
mode);
              Type:
                          Subroutine
              Purpose: 
                          compute the count, min, median, max, mean, mode of the non-missing 
elements of the time series array 
              Input:   
                          timedata[*] : time series array 
              Output: 
                          count       : integer as the total number of non-missing elements of 
the time series array
                          min         : float value as the mininum of the non-missing elements 
of the time series array
                          median      : float value as the median of the non-missing elements 
of the time series array
11                                      The SAS System              14:29 Monday, April 9, 2018

                          max         : float value as the maxinum of the non-missing elements 
of the time series array
                          mean        : float value as the mean of the non-missing elements of 
the time series array
                          mode        : float value as the mode of the non-missing elements of 
the time series array
          
          
***********************************************************************************************
************/
              subroutine ci_compute_basic_freq(timedata[*], count, min, median, max, mean, 
mode);
                  outargs count, min, median, max, mean, mode;
                  count=0;
                  min=.;
                  median=.;
                  max=.;
                  mean=.;
                  mode=.;
                  call ci_compute_order_stats(timedata, min, median, max);
                  call ci_compute_mean(timedata, mean, count);
                  array freq[1,1]/NOSYMBOLS;
                  call dynamic_array(freq, count,2);
                  fcount=0;
                  do i=1 to dim(timedata);
                    if timedata[i] ne . then do;
                      if fcount=0 then do;
                        fcount=fcount+1;
                        freq[fcount,1]=timedata[i];
                        freq[fcount,2]=1;
                      end;
                      else do;
                        found=0;
                        do j=1 to fcount;
                          if freq[j,1]=timedata[i] then do;
                            found=1;
                            freq[j,2]=freq[j,2]+1;
                          end;
                        end;
                        if found eq 0 then do;
                          fcount=fcount+1;
                          freq[fcount,1]=timedata[i];
                          freq[fcount,2]=1;                        
                        end;
                      end;
                    end;
                  end;
                  if fcount>0 then do;
                    modeC=freq[1,2];
                    mode = freq[1,1];
12                                      The SAS System              14:29 Monday, April 9, 2018

                    if fcount>1 then do;
                      do i=2 to fcount;
                        if freq[i,2]>=modeC then do;
                          modeC=freq[i,2];
                          mode = freq[i,1];
                        end;
                      end;
                    end;
                  end;
                  
              endsub;          
          
          
/**********************************************************************************************
*************
              API:
                          ci_find_active_period_range(activeDemand[*], firstPartialFlag, 
lastPartialFlag, 
                                                      periodStart[*], periodEnd[*], 
periodCount, rc);
              Type:
                          Subroutine
              Purpose: 
                          Loop through the active demand series, identify the start/end index 
for each active demand period
              Input:   
                          activeDemand      : active demand array (non-active periods are 
filled with .)
                          firstPartialFlag  : 0/1 flag indicating if the first period is 
included or not if the first period is partial
                          lastPartialFlag   : 0/1 flag indicating if the last period is 
included or not if the last period is partial
                          
              Output: 
                          periodStart       : array that stores the period start index value
                          periodEnd         : array that stores the period end index value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          rc                : return code : 0: success; 1: periodStart and 
periodEnd have different sizes; 
                                                            2: others
                          
          
***********************************************************************************************
************/
              subroutine ci_find_active_period_range(activeDemand[*],firstPartialFlag, 
lastPartialFlag, 
                                                      periodStart[*], periodEnd[*], 
periodCount, rc);
                  outargs periodStart, periodEnd, periodCount, rc;
13                                      The SAS System              14:29 Monday, April 9, 2018

                  rc=2;
                  periodCount=0;
                  do i=1 to dim(periodStart);
                    periodStart[i]=.;
                  end;
                  do i=1 to dim(periodEnd);
                    periodEnd[i]=.;
                  end;
                  rc = 1;
                  if dim(periodStart) eq dim(periodEnd) then do;
                    rc = 2;
                    size=dim(activeDemand);
                    if activeDemand[1] ne . and firstPartialFlag=1 then do;
                      periodCount=periodCount+1;
                      periodStart[periodCount]=1;
                      if activeDemand[2] eq . then do;
                        periodEnd[periodCount]=1;
                      end;
                    end;
                    do i=1+1 to size-1;
                      if activeDemand[i] ne . and activeDemand[i-1] eq . then do;
                        periodCount=periodCount+1;
                        periodStart[periodCount]=i;
                      end;
                      if activeDemand[i] ne . and activeDemand[i+1] eq . then do;
                        periodEnd[periodCount]=i;
                      end;
                    end;
                    if activeDemand[size] ne . then do;
                      i=size;
                      if periodCount eq 0 then do;
                        periodCount = periodCount+1;
                        periodStart[periodCount]=i;
                        periodEnd[periodCount]=i;
                      end;
                      else do;
                        if activeDemand[i-1] eq . then do;
                          periodCount=periodCount+1;
                          periodStart[periodCount]=i;
                        end;
                        periodEnd[periodCount]=i;                  
                      end;
                      if lastPartialFlag ne 1 then do;
                        periodEnd[periodCount]=.;
                        periodStart[periodCount]=.;
                        periodCount=periodCount-1;
                      end;
                    end; 
                    rc = 0;
                  end;/*if dim(periodStart) eq dim(periodEnd) then do;*/
14                                      The SAS System              14:29 Monday, April 9, 2018


              endsub;

          
/**********************************************************************************************
*************
              API:
                          ci_find_offseason_period_range(periodStart[*], periodEnd[*], 
periodCount, demandSize, firstPartialFlag, lastPartialFlag, 
                                                         offStart[*], offEnd[*], offCount, rc);
              Type:
                          Subroutine
              Purpose: 
                          Loop through the active demand series start/end, identify the 
start/end index for each off season period
              Input:   
                          periodStart       : array that stores the period start index value
                          periodEnd         : array that stores the period end index value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          demandSize        : total number of demand obs
                          firstPartialFlag  : 0/1 flag indicating if the first period is 
included or not if the first period is partial
                          lastPartialFlag   : 0/1 flag indicating if the last period is 
included or not if the last period is partial
                          
              Output: 
                          offStart          : array that stores the off season period start 
index value
                          offEnd            : array that stores the off season period end 
index value
                          offCount          : number of valid elements in offStart and offEnd
                          rc                : return code : 0: success; 1: offStart and offEnd 
have different sizes; 
                                                            2: others
                          
          
***********************************************************************************************
************/
              subroutine ci_find_offseason_period_range(periodStart[*], periodEnd[*], 
periodCount, demandSize, firstPartialFlag, lastPartialFlag, 
                                                        offStart[*], offEnd[*], offCount, rc);
                  outargs offStart, offEnd, offCount, rc;
                  rc=2;
                  offCount=0;
                  do i=1 to dim(offStart);
                    offStart[i]=.;
                  end;
                  do i=1 to dim(offEnd);
                    offEnd[i]=.;
15                                      The SAS System              14:29 Monday, April 9, 2018

                  end;
                  rc = 1;
                  if dim(offStart) eq dim(offEnd) then do;
                    rc = 2;
                    offCount = 0;
                    if periodCount=0 then do;
                      if firstPartialFlag eq 1 or lastPartialFlag eq 1 then do;
                        offCount = offCount+1;
                        offStart[offCount]=1;
                        offEnd[offCount]=demandSize;
                      end;
                    end;
                    else do;
                      tmpIndex = 1;
                      if periodStart[1] eq 1 then do;
                        offCount = offCount+1;
                        offStart[offCount]= periodEnd[1]+1;
                        tmpIndex=2;
                      end;
                      else do;
                        if firstPartialFlag eq 1 then do;
                          offCount = offCount+1;
                          offStart[offCount]= 1;
                        end;                     
                      end;
                      if periodCount>=tmpIndex then do;
                        do i=tmpIndex to periodCount;
                          if offCount>0 then offEnd[offCount]=periodStart[i]-1;
                          offCount = offCount+1;
                          offStart[offCount]=periodEnd[i]+1;
                        end;
                      end;
                      if periodEnd[periodCount] lt demandSize and lastPartialFlag eq 1 then do;
                        if offCount>0 then offEnd[offCount]=demandSize;
                      end;
                      else do;
                        if offCount>0 then do;
                          offStart[offCount]=.;
                          offCount = offCount-1;
                        end;
                      end;
                    end;/*else do for if periodCount=0 then do;*/
                    rc = 0;
                  end;/*if dim(offStart) eq dim(offEnd) then do;*/

              endsub;

                        
          
/**********************************************************************************************
16                                      The SAS System              14:29 Monday, April 9, 2018

*************
              API:
                          ci_find_active_event(activeDemand[*], timeID[*], eventFile $, 
eventSize, interval $, eventDefBufferLen, eventIdx, rc);
              Type:
                          Subroutine
              Purpose: 
                          Loop through all events defined in eventFile and compare with 
activeDemand patterns, to find 
                          the event that the the activeDemand always occur within or close to
              Input:   
                          activeDemand      : active demand array (non-active periods are 
filled with .)
                          timeID            : timeID series (should have the same size as 
activeDemand)
                          eventFile         : sas data set that stores the event definition 
information
                                              the eventFile contains the following columns: 
event_idx , event_name, year, event_date, weight
                          eventSize         : the number of observations in the data set 
eventFile
                          interval          : time interval
                          eventDefBufferLen : a buffer length that defines "within or close to"
                          
              Output: 
                          eventIdx          : the index for the found event (missing if no 
event is found)
                          rc                : return code : 0: success; 1: eventSize<=0; 2: 
activeDemand and timeID have different sizes; 3: error in read_array;
                                                            4: no active periods; 5: others
                          
          
***********************************************************************************************
************/
              subroutine ci_find_active_event(activeDemand[*], timeID[*], eventFile $, 
eventSize, interval $, eventDefBufferLen, eventIdx, rc);
                  outargs eventIdx, rc;
                  eventIdx = .;
                  rc = 1;
                  if eventSize>0 then do;
                    rc=5;
                    demandSize = dim(activeDemand);
                    if demandSize ne dim(timeID) then rc=2;
                    else do;
                      /*copy array from eventFile*/
                      array tmp[1,1] / nosymbols;
                      call dynamic_array(tmp, eventSize, 3);
                      do t=1 to eventSize;
                        tmp[t,1]=.; tmp[t,2]=.; tmp[t,3]=.;
                      end;
17                                      The SAS System              14:29 Monday, April 9, 2018

                      temp_rc = read_array(eventFile, tmp, 'event_idx' , 'event_date', 
'weight');
                      
                      if temp_rc=0 then do;
                      
                        /*identify active period range*/
                        array periodStart[1] / nosymbols;
                        array periodEnd[1] / nosymbols;
                        call dynamic_array(periodStart, demandSize);
                        call dynamic_array(periodEnd, demandSize);
                        array offStart[1] / nosymbols;
                        array offEnd[1] / nosymbols;
                        call ci_find_active_period_range(activeDemand, 1, 1, periodStart, 
periodEnd, periodCount, tmp_rc);

                        if periodCount >0 then do;

                          /*get unique list of event*/
                          array eventList[1] / nosymbols;
                          call dynamic_array(eventList, eventSize);
                          eventCount = 0;
                          do i=1 to eventSize;
                            if eventCount>0 then do;
                              if tmp[i,1] ne . then do;
                                found=0;
                                do j=1 to eventCount;
                                  if tmp[i,1] eq eventList[j] then found=1;
                                end;
                                if found eq 0 then do;
                                  eventCount = eventCount+1;
                                  eventList[eventCount]=tmp[i,1];
                                end;
                              end;
                            end;
                            else do; /*if eventCount>0 then do;*/
                              if tmp[i,1] ne . then do;
                                eventCount = 1;
                                eventList[eventCount]=tmp[i,1];
                              end;
                            end;
                          end;

                          /*candidate rule: for each full cycle active period, the event 
should be fall into the buffer range */                        
                          array candiList[1] / nosymbols;
                          call dynamic_array(candiList, eventCount);
                          candiSize=0;
                          do i=1 to eventCount;
                            candiList[i]=.;
                          end;
18                                      The SAS System              14:29 Monday, April 9, 2018

                          do i=1 to eventCount;
                            event=eventList[i];
                            out=0;
                            do k=1 to periodCount;
                              found=0;
                              do j=1 to eventSize;
                                if tmp[j,1] eq event then do;
                                  s=periodStart[k];
                                  e=periodEnd[k];
                                  bc = INTCK( interval, timeID[s], tmp[j,2]);
                                  ac = INTCK( interval, tmp[j,2], timeID[e]);
                                  if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then 
found=1;
                                end;
                              end;
                              if found eq 0 and not ((k=1 and periodStart[k]=1) or 
(k=periodCount and periodEnd[k]=demandSize)) then out=1;
                            end;                         
                            if out eq 0 then do;
                              candiSize=candiSize+1;
                              candiList[candiSize]=event;
                            end;
                          end;
                          
                          if candiSize eq 1 then eventIdx=candiList[1];
                          else if candiSize > 1 then do;

                            /*compare weight and distance stability*/
                            array weightList[1] / nosymbols;
                            call dynamic_array(weightList, candiSize);
                            maxWeight=.;
                            array distList[1] / nosymbols;
                            call dynamic_array(distList, candiSize);
                            array beforeDist[1] / nosymbols;
                            array afterDist[1] / nosymbols;
                            call dynamic_array(beforeDist, eventSize);
                            call dynamic_array(afterDist, eventSize);
                            minDist=.;
                            do i=1 to candiSize;
                              event=candiList[i];
                              weightList[i]=.;
                              distList[i]=.; 
                              do j=1 to eventSize;
                                beforeDist[j]=.;
                                afterDist[j]=.;
                              end;
                              dCount=0;
                              beforeDistMean=.;
                              afterDistMean=.;
                              do j=1 to eventSize;
19                                      The SAS System              14:29 Monday, April 9, 2018

                                if tmp[j,1] eq event then do;
                                  do k=1 to periodCount;
                                    s=periodStart[k];
                                    e=periodEnd[k];
                                    bc = INTCK( interval, timeID[s], tmp[j,2]);
                                    ac = INTCK( interval, tmp[j,2], timeID[e]);
                                    if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then 
do;
                                      if weightList[i] ne . then 
weightList[i]=weightList[i]+tmp[j,3];
                                      else weightList[i]=weightList[i];
                                      dCount=dCount+1;
                                      beforeDist[dCount]=bc;
                                      afterDist[dCount]=ac;
                                      if beforeDistMean ne . then 
beforeDistMean=beforeDistMean+beforeDist[dCount];
                                      else beforeDistMean=beforeDist[dCount];
                                      if afterDistMean ne . then 
afterDistMean=afterDistMean+afterDist[dCount];
                                      else afterDistMean=afterDist[dCount];
                                    end;
                                  end;
                                end;
                              end;
                              if weightList[i] ne . then do; 
                                weightList[i]=weightList[i]/dCount;
                                if maxWeight eq . then maxWeight=weightList[i];
                                else do;
                                  if weightList[i]>maxWeight then maxWeight=weightList[i];
                                end;
                              end; 
                              if dCount>0 then do;
                                beforeDistMean=beforeDistMean/dCount;
                                afterDistMean=afterDistMean/dCount;
                                distList[i]=0;
                                do j=1 to dCount;
                                  
distList[i]=distList[i]+(beforeDist[j]-beforeDistMean)**2+(afterDist[j]-afterDistMean)**2;
                                end;
                                distList[i]=sqrt (distList[i] / (dCount-1));
                              end;                            
                            end;/*do i=1 to candiSize;*/
                            
                            
                            array candiList2[1] / nosymbols;
                            call dynamic_array(candiList2, candiSize);
                            candiSize2=0;
                            if maxWeight ne . then do;
                              do i=1 to candiSize;
                                if weightList[i] eq maxWeight then do;
20                                      The SAS System              14:29 Monday, April 9, 2018

                                  candiSize2=candiSize2+1;
                                  candiList2[candiSize2]=candiList[i];
                                  if minDist eq . then minDist=distList[i];
                                  else if distList[i]<minDist then minDist=distList[i];
                                end;
                              end;
                            end;
                            else do;
                              candiSize2=candiSize;
                              do i=1 to candiSize;
                                candiList2[i]=candiList[i];
                                if minDist eq . then minDist=distList[i];
                                else if distList[i]<minDist then minDist=distList[i];
                              end;
                            end;
                            
                            /*more than one candidate, break the tie*/
                            if candiSize2 eq 1 then eventIdx=candiList2[1];
                            else if candiSize2 > 1 then do;
                              if minDist ne . then do;
                                array candiList3[1] / nosymbols;
                                call dynamic_array(candiList3, candiSize2);
                                candiSize3=0;
                                do i=1 to candiSize2;
                                  if distList[i] eq minDist then do;
                                    candiSize3=candiSize3+1;
                                    candiList3[candiSize3]=candiList2[i];
                                  end;
                                end; 
                                eventIdx=candiList3[1];
                              end;
                              else do;
                                eventIdx=candiList2[1];
                              end;                             
                            end;
                
                          end;/*else if candiSize > 1 then do;*/
                          rc=0;
                          
                        end;/*if periodCount >0 then do;*/
                        else rc=4;/*else for if periodCount >0 then do;*/
                      end;/*if temp_rc=0 then do;*/
                      else rc=3;/*if temp_rc=0 then do;*/
                    end;/*else do for 'if demandSize ne dim(timeID) then rc=2;'*/
                  end;/*if eventSize>0 then do;*/
              endsub;
              
          
/**********************************************************************************************
*************
21                                      The SAS System              14:29 Monday, April 9, 2018

              API:
                          ci_get_event_date(eventFile $, eventSize, eventIdx, eventDate[*], 
rc);
              Type:
                          Subroutine
              Purpose: 
                          get a list of event dates for a particular eventIdx
              Input:   
                          eventFile         : sas data set that stores the event definition 
information
                                              the eventFile contains the following columns: 
event_idx , event_name, year, event_date, weight
                          eventSize         : the number of observations in the data set 
eventFile
                          eventIdx          : the index for the event           
              Output: 
                          eventDate         : array that stores the event dates for eventIdx
                          eventCount        : number of event occurence
                          rc                : return code : 0: success; 1: error in 
read_array; 2: others
                          
          
***********************************************************************************************
************/
              subroutine ci_get_event_date(eventFile $, eventSize, eventIdx, eventDate[*], 
eventCount, rc);
                  outargs eventDate, eventCount, rc;
                  
                  rc=2;
                  size= dim(eventDate);
                  do i=1 to size;
                    eventDate[i]=.;
                  end;
                  eventCount=0;
                  array tmp[1,1] / nosymbols;
                  call dynamic_array(tmp, eventSize, 2);
                  do t=1 to eventSize;
                    tmp[t,1]=.; tmp[t,2]=.; 
                  end;
                  rc=1;
                  temp_rc = read_array(eventFile, tmp, 'event_idx' , 'event_date');
                  if temp_rc=0 then do;
                    do t=1 to eventSize;
                      if tmp[t,1] eq eventIdx and tmp[t,2] ne . and eventCount<size then do;
                        eventCount = eventCount+1;
                        eventDate[eventCount]=tmp[t,2];
                      end;
                    end;
                    rc=0;
                  end;
22                                      The SAS System              14:29 Monday, April 9, 2018


              endsub; 
                        
          
/**********************************************************************************************
*************
              API:
                          ci_compute_event_distance(periodStart[*], periodEnd[*], periodCount, 
timeID[*], demandSize, 
                                                    eventDate[*], eventCount, interval $, 
eventDefBufferLen, eventIdx,
                                                    beforeDist[*], afterDist[*], rc);
              Type:
                          Subroutine
              Purpose: 
                          Loop through the period information and event information, identify 
the event dates and period-event distance
              Input:   
                          periodStart       : array that stores the period start index value
                          periodEnd         : array that stores the period end index value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          timeID            : timeID series (should have the same size as 
activeDemand)
                          demandSize        : total number of timeID size
                          eventDate         : array that stores the event dates for eventIdx
                          eventCount        : number of event occurence
                          interval          : time interval
                          eventDefBufferLen : a buffer length that defines "within or close 
to"  
                          eventIdx          : the index for the event           
                          
              Output: 
                          beforeDist        : array that stores the periodStart-event distance
                          afterDist         : array that stores the event-periodEnd distance
                          rc                : return code : 0: success; 1: eventCount=0 or 
periodCount=0 2: output array size does not match;
                                                            3: others
                          
          
***********************************************************************************************
************/
              subroutine ci_compute_event_distance(periodStart[*], periodEnd[*], periodCount, 
timeID[*], demandSize, 
                                                    eventDate[*], eventCount, interval $, 
eventDefBufferLen, eventIdx,
                                                    beforeDist[*], afterDist[*], rc);
                  outargs beforeDist, afterDist, rc;

                  rc= 3;
23                                      The SAS System              14:29 Monday, April 9, 2018

                  do t=1 to dim(beforeDist); beforeDist[t]=.; end;
                  do t=1 to dim(afterDist); afterDist[t]=.; end;
                  rc=1;
                  if eventCount>0 and periodCount>0 then do;
                    rc=2;
                    if dim(beforeDist) eq dim(afterDist) then do;
                      rc=3;
                      count=0;
                      do j=1 to eventCount;
                        do k=1 to periodCount;
                          s=periodStart[k];
                          e=periodEnd[k];
                          bc = INTCK( interval, timeID[s], eventDate[j]);
                          ac = INTCK( interval, eventDate[j], timeID[e]);
                          if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then do;
                            count=count+1;
                            beforeDist[count]=bc;
                            afterDist[count]=ac;
                          end;
                        end;
                      end;                      
                      rc=0;
                    end;
                  end;
                  
              endsub;
              
             
/**********************************************************************************************
*************
              API:
                          ci_event_compute_next_period_distance(eventDate[*], eventCount, 
interval $, date, beforeDist);
              Type:
                          function
              Purpose: 
                          Loop through the event list, and compute the distance to the next 
event
              Input:   
                          eventDate         : array that stores the event dates for eventIdx
                          eventCount        : number of event occurence
                          interval          : time interval
                          date              : the current date
                          beforeDist        : the number of periods each in-season periods 
starts compared with event date          
                          
              Output: 
                          dist
                          
          
24                                      The SAS System              14:29 Monday, April 9, 2018

***********************************************************************************************
************/
              function ci_event_compute_next_period_distance(eventDate[*], eventCount, 
interval $, date, beforeDist);
                  dist=.;
                  do i=1 to eventCount;
                    bc = INTCK( interval, date, eventDate[i]);
                    if bc>beforeDist then do;
                      if dist eq . then dist=bc;
                      else if bc<dist then dist=bc;
                    end;
                  end;
                  if dist ne . then dist=dist-beforeDist;
                  return(dist);
              endsub;
              

          
/**********************************************************************************************
*************
              API:
                          ci_run_forecast(demand[*], timeID[*], seriesID[*], interval $, 
seasonality, lead, sign $,
                                          criterion $, repositoryNm $, diagEstNm $, indataset 
$, outdataset $, 
                                          forecast[*], fTimeID[*], rc);
              Type:
                          Subroutine
              Purpose: 
                          get forecast for a given data
              Input:   
                          demand            : array that stores the demand series
                          timeID            : timeID series (should have the same size as 
demand)
                          interval          : time interval 
                          seasonality       : season cycle length
                          lead              : number of periods forecast out
                          sign              : the sign for forecast values, possible values 
are "MIXED", "NONNEGATIVE", "NONPOSITIVE"
                          criterion         : criterion used to select the forecast model
                          repositoryNm      : name of the modeling repository
                          diagEstNm         : name of the diag estimation results should be 
written to
                          indataset         : name of the dataset that the series are going to 
be written and used for forecast call
                          outdataset        : name of the dataset the forecast results should 
be written out
                          
              Output: 
                          forecast          : array that stores the forecast results 
25                                      The SAS System              14:29 Monday, April 9, 2018

                          fTimeID           : array that stores the forecast time id
                          rc                : return code : 0: success; 1: input array sizes 
do not match;  
                                                            2: error in write_array; 3: error 
in calling macro; 
                                                            4: error in read_array; 5: others
                          
          
***********************************************************************************************
************/
              subroutine ci_run_forecast(demand[*], timeID[*], interval $, seasonality, lead, 
sign $,
                                          criterion $, repositoryNm $, diagEstNm $, indataset 
$, outdataset $, 
                                          forecast[*], fTimeID[*], rc);
                  outargs forecast, fTimeID, rc;

                  rc= 1;
                  do i=1 to dim(fTimeID);
                    fTimeID[i]=.;
                  end;
                  do i=1 to dim(forecast);
                    forecast[i]=.;
                  end;
                  if dim(demand) eq dim(timeID) then do;
                    size=dim(demand);
                    rc=5;
                    array series[1,2] / nosymbols;
                    call dynamic_array(series, size, 2);
                    do t=1 to size;
                       series[t,1]=timeID[t];
                       series[t,2]=demand[t];
                    end;
                    
                    temp_rc = write_array(indataset, series, 'time_id', 'demand');      
                    rc = 2;
                    if temp_rc=0 then do;
                      rc = 3;
                      temp_rc = run_macro('ci_run_hpf', indataset, outdataset, interval, 
criterion, repositoryNm, diagEstNm, seasonality, lead);
                      if temp_rc = 0 then do;
                        rc=4;
                        array fcst[1,2] / nosymbols;
                        call dynamic_array(fcst, size+lead,2);
                        temp_rc = read_array(outdataset, fcst, 'time_id', 'predict');
                        if temp_rc = 0 then do;
                          outsize=dim(fTimeID);
                          if outsize>size+lead then outsize=size+lead;
                          do i=1 to outsize;
                            fTimeID[i]=fcst[i, 1];
26                                      The SAS System              14:29 Monday, April 9, 2018

                          end;
                          outsize=dim(forecast);
                          if outsize>size+lead then outsize=size+lead;
                          do i=1 to outsize;
                            forecast[i]=fcst[i, 2];
                            if forecast[i] ne . then do;
                              if sign eq "NONNEGATIVE" and forecast[i]<0 then forecast[i]=0;
                              if sign eq "NONPOSITIVE" and forecast[i]>0 then forecast[i]=0; 
                            end;
                          end;
                          rc=0;
                        end;
                      end;
                    end; 
                         
                  end;/*if dim(demand) eq dim(timeID) then do;*/

              endsub;   
              
          
/**********************************************************************************************
*************
              API:
                          ci_stretch_squeeze_series(origSeries[*], origPeriodStart[*], 
origPeriodEnd[*], origPeriodCount, newLen,
                                                   newPeriodStart[*], newPeriodEnd[*], 
newSeries[*], newCount, rc);
              Type:
                          Subroutine
              Purpose: 
                          generate a new series in which each period defined should be 
squeezed/stretch to the length of newLen
              Input:   
                          origSeries        : array that stores the original demand series
                          origPeriodStart   : array that stores the period start index values 
in the original series
                          origPeriodEnd     : array that stores the period end index value in 
the original series
                          origPeriodCount   : number of valid elements in origPeriodStart and 
origPeriodEnd
                          newLen            : the new length each original period should 
squeenze/stretch into
                          
              Output: 
                          newPeriodStart    : array that stores the period start index values 
in the new series, which matches each origPeriodStart index
                          newPeriodEnd      : array that stores the period end index value in 
the new series, which matches each origPeriodEnd index
                          newSeries         : array that stores the new series
                          newCount          : size of the new series
27                                      The SAS System              14:29 Monday, April 9, 2018

                          rc                : return code : 0: success; 1: origPeriodCount=0; 
2: newLen<=0
                                                            3: others
                          
          
***********************************************************************************************
************/              
              subroutine ci_stretch_squeeze_series(origSeries[*], origPeriodStart[*], 
origPeriodEnd[*], origPeriodCount, newLen,
                                                   newPeriodStart[*], newPeriodEnd[*], 
newSeries[*], newCount, rc);
                outargs newPeriodStart, newPeriodEnd, newSeries, newCount, rc;
                
                rc=1;
                newCount=0;
                do i=1 to dim(newPeriodStart); newPeriodStart[i]=.; end;
                do i=1 to dim(newPeriodEnd); newPeriodEnd[i]=.; end;
                do i=1 to dim(newSeries); newSeries[i]=.; end;
                if origPeriodCount>0 then do;
                  rc=2;
                  if newLen>=1 then do;
                    rc=3;
                    size=dim(origSeries);
                    lastIndex=0;
                    
                    do i=1 to origPeriodCount;
                      if origPeriodStart[i]>lastIndex+1 then do;
                        do j=lastIndex+1 to origPeriodStart[i]-1;
                          newCount = newCount+1;
                          newSeries[newCount]=origSeries[j];
                        end;
                        lastIndex = origPeriodStart[i]-1;
                      end;                  
                      
                      origLen = origPeriodEnd[i]-origPeriodStart[i]+1;
                      newPeriodStart[i]=newCount+1;
  
                      if origLen eq newLen then do;
                        do j=origPeriodStart[i] to origPeriodEnd[i];
                          newCount = newCount+1;
                          newSeries[newCount]=origSeries[j];
                        end;                      
                      end;
                      else if origLen eq 1 then do;
                        k = origPeriodStart[i];
                        do j=1 to newLen;
                          newCount = newCount+1;
                          newSeries[newCount]=origSeries[k];
                        end;
                      end;
28                                      The SAS System              14:29 Monday, April 9, 2018

                      else do;
                        do j=1 to newLen;
                          newCount = newCount+1;
                          if newLen eq 1 then pos=(origPeriodStart[i] +origPeriodEnd[i])/2;
                          else pos=origPeriodStart[i] +(j-1)*(origLen-1)/(newLen-1);
                          k=floor(pos);
                          if pos eq k then newSeries[newCount]=origSeries[k];
                          else do;
                            if origSeries[k] ne . and origSeries[k+1] ne . then 
                              
newSeries[newCount]=(k+1-pos)*origSeries[k]+(pos-k)*origSeries[k+1];
                            else newSeries[newCount]=.;
                          end;
                        end;
                      end;
                      lastIndex = origPeriodEnd[i];
                      newPeriodEnd[i]=newCount;
                    end;/*do i=1 to origPeriodCount;*/
                    
                    if lastIndex lt size then do;
                      do i=lastIndex+1 to size;
                        newCount = newCount+1;
                        newSeries[newCount]=origSeries[i];
                      end;
                    end;
                    rc=0;
                  end;/*if newLen>=1 then do;*/
                end;/*if origPeriodCount>0 then do;*/
             endsub;

              
          
/**********************************************************************************************
*************
              API:
                          ci_recover_stretch_squeeze_series(newPeriodStart[*], 
newPeriodEnd[*], newSeries[*], newCount,newLen,
                                                            origPeriodStart[*], 
origPeriodEnd[*], origPeriodCount
                                                            origSeries[*], origCount, rc);
              Type:
                          Subroutine
              Purpose: 
                          recover the original series stretch or squeezed by 
ci_stretch_squeeze_series
              Input:   
                          newPeriodStart    : array that stores the period start index values 
in the new series, which matches each origPeriodStart index
                          newPeriodEnd      : array that stores the period end index value in 
the new series, which matches each origPeriodEnd index
29                                      The SAS System              14:29 Monday, April 9, 2018

                          newSeries         : array that stores the new series
                          newCount          : size of the new series
                          newLen            : the new length each original period should 
squeenze/stretch into
                          origPeriodStart   : array that stores the period start index values 
in the original series
                          origPeriodEnd     : array that stores the period end index value in 
the original series
                          origPeriodCount   : number of valid elements in origPeriodStart and 
origPeriodEnd
                          
              Output: 
                          origSeries        : array that stores the original demand series
                          origCount         : size of the original series
                          rc                : return code : 0: success; 1: origPeriodCount=0; 
2: newLen<=0
                                                            3: others
                          
          
***********************************************************************************************
************/              
              subroutine ci_recover_stretch_squeeze_series(newPeriodStart[*], newPeriodEnd[*], 
newSeries[*], newCount,newLen,
                                                            origPeriodStart[*], 
origPeriodEnd[*], origPeriodCount,
                                                            origSeries[*], origCount, rc);
                outargs origSeries, origCount, rc;
                
                rc=1;
                origCount=0;
                do i=1 to dim(origSeries); origSeries[i]=.; end;
                if origPeriodCount>0 then do;
                  rc=2;
                  if newLen>=1 then do;
                    rc=3;
                    
                    lastIndex=0;
                    do i=1 to origPeriodCount;
                      if newPeriodStart[i]>lastIndex+1 then do;
                        do j=lastIndex+1 to newPeriodStart[i]-1;
                          origCount = origCount+1;
                          origSeries[origCount]=newSeries[j];
                        end;
                        lastIndex = newPeriodStart[i]-1;
                      end;                  
                      
                      origLen = origPeriodEnd[i]-origPeriodStart[i]+1;
  
                      if origLen eq newLen then do;
                        do j=newPeriodStart[i] to newPeriodEnd[i];
30                                      The SAS System              14:29 Monday, April 9, 2018

                          origCount = origCount+1;
                          origSeries[origCount]=newSeries[j];
                        end;                      
                      end;
                      else if newLen eq 1 then do;
                        k = newPeriodStart[i];
                        do j=1 to origLen;
                          origCount = origCount+1;
                          origSeries[origCount]=newSeries[k];
                        end;
                      end;
                      else do;
                        do j=1 to origLen;
                          origCount = origCount+1;
                          if origLen eq 1 then pos=(newPeriodStart[i] +newPeriodEnd[i])/2;
                          else pos=newPeriodStart[i] +(j-1)*(newLen-1)/(origLen-1);
                          k=floor(pos);
                          if pos eq k then origSeries[origCount]=newSeries[k];
                          else do;
                            if newSeries[k] ne . and newSeries[k+1] ne . then
                              
origSeries[origCount]=(k+1-pos)*newSeries[k]+(pos-k)*newSeries[k+1];
                            else origSeries[origCount]=.;
                          end;
                        end;
                      end;
                      lastIndex = newPeriodEnd[i];
                    end;/*do i=1 to origPeriodCount;*/
                    
                    if lastIndex lt newCount then do;
                      do i=lastIndex+1 to newCount;
                        origCount = origCount+1;
                        origSeries[origCount]=newSeries[i];
                      end;
                    end;
                    rc=0;
                  end;/*if newLen>=1 then do;*/
                end;/*if origPeriodCount>0 then do;*/
             endsub;

              
          
/**********************************************************************************************
*************
              API:
                          ci_run_forecast2(demand[*], seasonality, lead, sign $, forecast[*]);
              Type:
                          Subroutine
              Purpose: 
                          get a average forecast for a given series
31                                      The SAS System              14:29 Monday, April 9, 2018

              Input:   
                          demand            : array that stores the demand series
                          seasonality       : season cycle length
                          lead              : number of periods forecast out
                          sign              : the sign for forecast values, possible values 
are "MIXED", "NONNEGATIVE", "NONPOSITIVE"
                          
              Output: 
                          forecast          : array that stores the forecast results 
                          
          
***********************************************************************************************
************/
              subroutine ci_run_forecast2(demand[*], seasonality, lead, sign $, forecast[*]);
                  outargs forecast;
                  
                  do i=1 to dim(forecast);
                    forecast[i]=.;
                  end;
                  size=dim(demand);
                  trailMissLen=ci_compute_trail_missing_length(demand, size);
                  if trailMissLen>0 then size=size-trailMissLen;
                  array avg[1,1] / nosymbols;
                  call dynamic_array(avg, seasonality, 2);
                  do j=1 to seasonality;
                    avg[j,1]=.;
                    avg[j,2]=0;
                  end;
                  do i=1 to size;
                    if demand[i] ne . then do;
                      j= mod(i,seasonality);
                      if j eq 0 then j=seasonality;
                      if avg[j,1] ne . then avg[j,1]=avg[j,1]+demand[i];
                      else avg[j,1]=demand[i];
                      avg[j,2]=avg[j,2]+1;
                    end;
                  end;
                  do j=1 to seasonality;
                    if avg[j,2] ne 0 then avg[j,1]=avg[j,1]/avg[j,2];
                  end;
                  outsize=dim(forecast);
                  if outsize>size+lead then outsize=size+lead;
                  cycCount=ceil(outsize/seasonality);
                  array cycTot[1,2] / nosymbols;
                  call dynamic_array(cycTot, cycCount,2);
                  do i=1 to cycCount;
                    cycTot[i,1]=0;
                    cycTot[i,2]=0;
                  end;
                  do i=1 to size;
32                                      The SAS System              14:29 Monday, April 9, 2018

                    j= mod(i,seasonality);
                    if j eq 0 then j=seasonality;
                    k=ceil(i/seasonality);
                    if demand[i] ne . then do;
                      cycTot[k,1]=cycTot[k,1]+abs(demand[i]);
                      cycTot[k,2]=cycTot[k,2]+abs(avg[j,1]);
                    end;
                  end;
                  do i=1 to outsize;
                    j= mod(i,seasonality);
                    if j eq 0 then j=seasonality;
                    k=ceil(i/seasonality);
                    if cycTot[k,1] ne 0 and cycTot[k,2] ne 0 then
                      forecast[i]=avg[j,1]*cycTot[k,1]/cycTot[k,2];
                    else forecast[i]=avg[j,1];
                    if forecast[i] ne . then do;
                      if sign eq "NONNEGATIVE" and forecast[i]<0 then forecast[i]=0;
                      if sign eq "NONPOSITIVE" and forecast[i]>0 then forecast[i]=0; 
                    end;
                  end;
                  

              endsub;                 
              
          
/**********************************************************************************************
*************
              API:
                          ci_compute_forecast_measure(demand[*], forecast[*], size, measure $, 
score, count);
              Type:
                          Subroutine
              Purpose: 
                          get a average forecast for a given series
              Input:   
                          demand            : array that stores the demand series
                          forecast          : array that stores the forecast results 
                          size              : the size of the arrays that will be taken into 
consideration
                          measure           : name of the measurement, could be "MAPE", "MAE", 
"MSE" 
              Output: 
                          score             : the measurement score
                          count             : the number of observations used to scoring the 
results
                          
          
***********************************************************************************************
************/
              subroutine ci_compute_forecast_measure(demand[*], forecast[*], size, measure $, 
33                                      The SAS System              14:29 Monday, April 9, 2018

score, count);
                  outargs score, count;
                  
                  score=.;
                  count=0;
                  msize = size;
                  if dim(demand)<msize then msize=dim(demand);
                  if dim(forecast)<msize then msize=dim(forecast);
                  array avg[1] / nosymbols;
                  call dynamic_array(avg, msize);
                  do i=1 to msize;
                    avg[i]=.;
                  end;
                  do i=1 to msize;
                    if demand[i] ne . and forecast[i] ne . then do;
                      count=count+1;
                      if measure="MAPE" then do;
                        if demand[i] ne 0 then 
avg[count]=abs((demand[i]-forecast[i])/demand[i]);
                        else if forecast[i] ne 0 then 
avg[count]=abs((demand[i]-forecast[i])/forecast[i]);
                        else avg[count]=0;
                      end;
                      else if measure="MAE" then avg[count]=abs(demand[i]-forecast[i]);
                      else if measure="MSE" then avg[count]=(demand[i]-forecast[i])**2;
                    end;
                  end;
                  if count>0 then do;
                    score=0;
                    do i=1 to msize;
                      if avg[i] ne . then score=score+avg[i];
                    end;
                    score=score/count;
                  end;

              endsub;                
          
/**********************************************************************************************
*************
              API:
                          ci_find_event_series_seasons(timeID[*], eventDate[*], eventCount, 
interval $, beforeDist, afterDist, 
                                                       seasonCode[*], inSeasonLen, rc);
              Type:
                          Subroutine
              Purpose: 
                          Generate season code for a particular event series on a given 
beforeDist and afterDist
              Input:   
                          timeID            : timeID series (should have the same size as 
34                                      The SAS System              14:29 Monday, April 9, 2018

activeDemand)
                          eventDate         : array that stores the event dates for eventIdx
                          eventCount        : number of event occurence
                          interval          : time interval
                          beforeDist        : a number indicates the distance between 
in-season start period and event date period
                          afterDist         : a number indicates the distance between event 
date period and in-season end period    
                          
              Output: 
                          seasonCode        : array that stores the season code for each 
observation in the demand series
                          inSeasonLen       : in-season period length
                          rc                : return code : 0: success; 1: eventCount=0; 2: 
others
                          
          
***********************************************************************************************
************/
              subroutine ci_find_event_series_seasons(timeID[*], eventDate[*], eventCount, 
interval $, beforeDist, afterDist, 
                                                      seasonCode[*], inSeasonLen, rc);
                  outargs seasonCode, inSeasonLen, rc;

                  rc= 2;
                  inSeasonLen=0;
                  do t=1 to dim(seasonCode); seasonCode[t]=.; end;
                  rc=1;
                  if eventCount>0 then do;
                    rc=2;
                    count=0;
                    do t=1 to dim(timeID);
                      found=0;
                      do j=1 to eventCount;
                        bc = INTCK( interval, timeID[t], eventDate[j]);
                        ac = INTCK( interval, eventDate[j], timeID[t]);
                        if bc<=beforeDist and ac<=afterDist then do;
                          found=1;
                          seasonCode[t]=beforeDist-bc+1;
                          if seasonCode[t]>inSeasonLen then inSeasonLen=seasonCode[t];
                        end;
                      end;
                      if found=0 then seasonCode[t]=0;
                    end;             
                    rc=0;
                  end;
                  
              endsub;              

          
35                                      The SAS System              14:29 Monday, April 9, 2018

/**********************************************************************************************
*************
              API:
                          ci_find_off_periods_by_code(seasonCode[*], firstPartialFlag, 
lastPartialFlag,
                                                      offStart[*], offEnd[*], offCount);
              Type:
                          Subroutine
              Purpose: 
                          Find the off season periods based on season code
              Input:   
                          seasonCode        : array that stores the season code for each 
observation in the demand series
                          firstPartialFlag  : 0/1 flag indicating if the first period is 
included or not if the first period is partial
                          lastPartialFlag   : 0/1 flag indicating if the last period is 
included or not if the last period is partial
                          
              Output: 
                          offStart          : array that stores the off season period start 
index value
                          offEnd            : array that stores the off season period end 
index value
                          offCount          : number of valid elements in offStart and offEnd
                          
          
***********************************************************************************************
************/
              subroutine ci_find_off_periods_by_code(seasonCode[*], firstPartialFlag, 
lastPartialFlag,
                                                      offStart[*], offEnd[*], offCount);
                  outargs offStart, offEnd, offCount;

                  offCount=0;
                  do t=1 to dim(offStart); offStart[t]=.; end;
                  do t=1 to dim(offEnd); offEnd[t]=.; end;
                  msize=dim(seasonCode);
                  do t=1 to dim(seasonCode);
                    if seasonCode[t] eq . and t<=msize then msize=t-1;
                  end;
                  
                  do t=1 to msize;
                    if seasonCode[t] eq 0 then do;
                      if t eq 1 then do;
                        if firstPartialFlag eq 1 then do;
                          offCount=offCount+1;
                          offStart[offCount]=1;
                        end;
                      end;
                      else if seasonCode[t-1] ne 0 then do;
36                                      The SAS System              14:29 Monday, April 9, 2018

                        offCount=offCount+1;
                        offStart[offCount]=t;
                      end;
                      if offCount>0 then do;
                        if t eq msize then offEnd[offCount]=t;
                        else if seasonCode[t+1] ne 0 then offEnd[offCount]=t;
                      end;
                    end;
                  end;
                  if offCount>0 then do;
                    if offEnd[offCount] ne . and offEnd[offCount] eq msize and lastPartialFlag 
eq 0 then do;
                      offStart[offCount]=.;
                      offEnd[offCount]=.;
                      offCount=offCount-1;
                    end;
                  end;

              endsub;

          
/**********************************************************************************************
*************
              API:
                          ci_find_inseason_periods_by_code(seasonCode[*], firstPartialFlag, 
lastPartialFlag,
                                                           periodStart[*], periodEnd[*], 
periodCount);
              Type:
                          Subroutine
              Purpose: 
                          Find the in season periods based on season code
              Input:   
                          seasonCode        : array that stores the season code for each 
observation in the demand series
                          firstPartialFlag  : 0/1 flag indicating if the first period is 
included or not if the first period is partial
                          lastPartialFlag   : 0/1 flag indicating if the last period is 
included or not if the last period is partial
                          
              Output: 
                          periodStart       : array that stores the in season period start 
index value
                          periodEnd         : array that stores the in season period end index 
value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          
          
***********************************************************************************************
37                                      The SAS System              14:29 Monday, April 9, 2018

************/
              subroutine ci_find_inseason_periods_by_code(seasonCode[*], firstPartialFlag, 
lastPartialFlag,
                                                          periodStart[*], periodEnd[*], 
periodCount);
                  outargs periodStart, periodEnd, periodCount;

                  periodCount=0;
                  do t=1 to dim(periodStart); periodStart[t]=.; end;
                  do t=1 to dim(periodEnd); periodEnd[t]=.; end;
                  msize=dim(seasonCode);
                  do t=1 to dim(seasonCode);
                    if seasonCode[t] eq . and t<=msize then msize=t-1;
                  end;
                  
                  if seasonCode[1] >1 and firstPartialFlag=1 then do;
                    periodCount=periodCount+1;
                    periodStart[periodCount]=1;
                  end;
                  do t=1 to msize;
                    if seasonCode[t] eq 1 then do;
                      periodCount=periodCount+1;
                      periodStart[periodCount]=t;
                    end;
                    if t<msize then do;
                      if seasonCode[t] ne 0 and seasonCode[t+1] <=1 then do;
                        periodEnd[periodCount]=t;
                      end;
                    end;
                    else if seasonCode[t] >1 then periodEnd[periodCount]=t;
                  end;
                  if periodCount>0 and periodEnd[periodCount]=msize and lastPartialFlag eq 0 
then do;
                    call ci_compute_order_stats(seasonCode, min, median, max);
                    if seasonCode[msize]<max then do;
                      periodStart[periodCount]=.;
                      periodEnd[periodCount]=.;
                      periodCount=periodCount-1;
                    end;
                  end;

              endsub;

                                   
          
/**********************************************************************************************
*************
              API:
                          ci_find_off_periods_length(offStart[*], offEnd[*], offCount, 
offSeasonRule $, totObs);
38                                      The SAS System              14:29 Monday, April 9, 2018

              Type:
                          function
              Purpose: 
                          Find the expected off periods length based on period information and 
rule
              Input:   
                          offStart          : array that stores the off season period start 
index value
                          offEnd            : array that stores the off season period end 
index value
                          offCount          : number of valid elements in offStart and offEnd
                          offSeasonRule     : rule used to find off season length, possible 
values are MIN, MAX, MEAN, MODE, MEDIAN, LAST
                          totObs            : total number of observations in the demand series
              Output: 
                          newLen
                          
          
***********************************************************************************************
************/
              function ci_find_off_periods_length(offStart[*], offEnd[*], offCount, 
offSeasonRule $, totObs);

                  newLen=0;
                  if offCount>0 then do;
                    array offRange[1]/NOSYMBOLS; 
                    call dynamic_array(offRange, offCount); 
                    
                    do k=1 to offCount;
                      if offEnd[k]<=totObs then offRange[k]=offEnd[k]-offStart[k]+1;
                      else offRange[k]=.;
                    end;
                    call ci_compute_basic_freq(offRange, _OFF_RANGE_COUNT, _OFF_RANGE_MIN, 
_OFF_RANGE_MEDIAN, _OFF_RANGE_MAX,
                                               _OFF_RANGE_MEAN, _OFF_RANGE_MODE);
                    if _OFF_RANGE_COUNT>0 then do;
                      if offSeasonRule eq "MIN" then newLen=_OFF_RANGE_MIN;
                      else if offSeasonRule eq "MAX" then newLen=_OFF_RANGE_MAX;
                      else if offSeasonRule eq "MEAN" then newLen=ceil(_OFF_RANGE_MEAN);
                      else if offSeasonRule eq "MODE" then newLen=_OFF_RANGE_MODE;
                      else if offSeasonRule eq "MED" then newLen=ceil(_OFF_RANGE_MEDIAN);
                      else do;
                        if offEnd[_OFF_RANGE_COUNT]>=totObs and _OFF_RANGE_COUNT>2 then 
newLen=offEnd[_OFF_RANGE_COUNT-1]-offStart[_OFF_RANGE_COUNT-1]+1;
                        else newLen=offEnd[_OFF_RANGE_COUNT]-offStart[_OFF_RANGE_COUNT]+1;
                      end;
                    end;
                  end;
                  return(newLen);
              endsub;
39                                      The SAS System              14:29 Monday, April 9, 2018



              
          
/**********************************************************************************************
*************
              API:
                          ci_split_series_by_period(origSeries[*],  totObs, PeriodStart[*], 
PeriodEnd[*], periodCount,
                                                     _inSeries[*], _offSeries[*], inIndex, 
offIndex);
              Type:
                          Subroutine
              Purpose: 
                          Find the off periods based on season code
              Input:   
                          origSeries        : array that stores the original series
                          totObs            : total number of observations
                          PeriodStart       : array that stores the off season period start 
index value
                          PeriodEnd         : array that stores the off season period end 
index value
                          periodCount       : number of valid elements in PeriodStart and 
PeriodEnd
                          
              Output: 
                          _inSeries         : array that stores the in season series
                          _offSeries        : array that stores the off season series
                          inIndex           : number of observations in _inSeries
                          offIndex          : number of observations in _offSeries
                          
          
***********************************************************************************************
************/
              subroutine ci_split_series_by_period(origSeries[*], totObs, PeriodStart[*], 
PeriodEnd[*], periodCount,
                                                     _inSeries[*], _offSeries[*], inIndex, 
offIndex);
                  outargs _inSeries, _offSeries, inIndex, offIndex;

                  offIndex=0; inIndex=0;
                  if PeriodStart[1]>1 then do;
                    do j=1 to PeriodStart[1]-1;
                      if j<=totObs then do;
                        inIndex=inIndex+1;
                        _inSeries[inIndex]=origSeries[j];
                      end;
                    end;
                  end;
                  do i=1 to periodCount;
40                                      The SAS System              14:29 Monday, April 9, 2018

                    do j=PeriodStart[i] to PeriodEnd[i];
                      if j<=totObs then do;
                        offIndex=offIndex+1;
                        _offSeries[offIndex]=origSeries[j];
                      end;
                    end;
                    
                    if i<periodCount then endIndex=PeriodStart[i+1]-1;
                    else endIndex=totObs;
                    if PeriodEnd[i]<endIndex then do;
                      do j=PeriodEnd[i]+1 to endIndex;
                        if j<=totObs then do;
                          inIndex=inIndex+1;
                          _inSeries[inIndex]=origSeries[j];
                        end;
                      end;
                    end;
                  end;

              endsub;     
              
          
/**********************************************************************************************
*************
              API:
                          ci_combine_two_series_by_period(inSeries[*], offSeries[*], totObs, 
PeriodStart[*], PeriodEnd[*], periodCount,
                                                          _combSeries[*], inIndex, offIndex, 
combIndex);
              Type:
                          Subroutine
              Purpose: 
                          Combine the in-season series and off season series togetheer
              Input:   
                         
                          inSeries          : array that stores the in season series
                          offSeries         : array that stores the off season series
                          totObs            : total number of observations
                          PeriodStart       : array that stores the off season period start 
index value
                          PeriodEnd         : array that stores the off season period end 
index value
                          periodCount       : number of valid elements in PeriodStart and 
PeriodEnd
                          
              Output: 
                          _combSeries       : array that stores the combined series
                          inIndex           : number of observations found in inSeries
                          offIndex          : number of observations found in offSeries
                          combIndex         : number of observations in the combined series
41                                      The SAS System              14:29 Monday, April 9, 2018

                          
          
***********************************************************************************************
************/
              subroutine ci_combine_two_series_by_period(inSeries[*], offSeries[*], totObs, 
PeriodStart[*], PeriodEnd[*], periodCount,
                                                         _combSeries[*], inIndex, offIndex, 
combIndex);
                  outargs _combSeries, inIndex, offIndex, combIndex;

                  combIndex=0;inIndex=0; offIndex=0;
                  if PeriodStart[1]>1 then do;
                    do j=1 to PeriodStart[1]-1;
                      combIndex=combIndex+1;
                      inIndex=inIndex+1;
                      _combSeries[combIndex]=inSeries[inIndex];
                    end;
                  end;
                  do i=1 to periodCount;
                    do j=PeriodStart[i] to PeriodEnd[i];
                      combIndex=combIndex+1;
                      offIndex=offIndex+1;
                      _combSeries[combIndex]=offSeries[offIndex];
                    end;
                    
                    if i<periodCount then endIndex=PeriodStart[i+1]-1;
                    else endIndex=totObs;
                    if PeriodEnd[i]<endIndex then do;
                      do j=PeriodEnd[i]+1 to endIndex;
                        combIndex=combIndex+1;
                        inIndex=inIndex+1;
                        _combSeries[combIndex]=inSeries[inIndex];
                      end;
                    end;
                  end; /*do i=1 to periodCount;*/

              endsub;              
              
          
/**********************************************************************************************
*************
              API:
                          ci_combine_series_season(demand[*], seasonCode[*], accumulate $, 
comb[*], combCount[*], size, rc);
              Type:
                          Subroutine
              Purpose: 
                          Combine the series based on season code
              Input:   
                          demand            : array that stores the demand series
42                                      The SAS System              14:29 Monday, April 9, 2018

                          seasonCode        : array that stores the season code for each 
observation in the demand series
                          accumulate        : off season period accumulate method, could be 
TOTAL, AVG, MAX, MED, MIN, FIRST, LAST, MODE
                          
              Output: 
                          comb              : array that stores combined series results
                          combCount         : array that stores the number of observations 
corresponding to each element in the combined series
                          size              : valid size of the combined series length
                          rc                : return code : 0: success; 1: invalid accumulate; 
2: others
                          
          
***********************************************************************************************
************/
              subroutine ci_combine_series_season(demand[*], seasonCode[*], accumulate $, 
comb[*], combCount[*], size, rc);
                  outargs comb, combCount, size, rc;

                  rc= 2;
                  size=0;
                  do t=1 to dim(comb); comb[t]=.; end;
                  do t=1 to dim(combCount); combCount[t]=.; end;
                  
                  msize=dim(demand);
                  do t=1 to dim(demand);
                    if seasonCode[t] eq . and t<=msize then msize=t-1;
                  end;
                  
                  array tmp[1] / nosymbols;
                  array offStart[1] / nosymbols;
                  array offEnd[1] / nosymbols;
                  call dynamic_array(tmp,msize);
                  call dynamic_array(offStart,msize);
                  call dynamic_array(offEnd,msize);
                  call ci_find_off_periods_by_code(seasonCode, 1, 1, offStart, offEnd, 
offCount);

                  if offCount>0 then do;
                    array eva[1] / nosymbols;
                    call dynamic_array(eva,offCount);
                    
                    do i=1 to offCount;
                      s=offStart[i];
                      ec=offEnd[i]-offStart[i]+1;
                      array off[1] / nosymbols;
                      call dynamic_array(off,ec);
                      do j=1 to msize;
                        off[j]=.;
43                                      The SAS System              14:29 Monday, April 9, 2018

                      end;
                      missFlag=0;
                      do j=1 to ec;
                        off[j]=demand[s+j-1];
                        if off[j] eq . then missFlag=1;
                      end;
                      eva[i]=.;
                      value=.;
                      if missFlag ne 1 then do;
                        if accumulate eq "TOTAL" then call ci_compute_sum(off, value, count);
                        else if accumulate eq "AVG" then call ci_compute_mean(off, value, 
count);
                        else if accumulate eq "MIN" then call ci_compute_order_stats(off, 
value, median, max);
                        else if accumulate eq "MED" then call ci_compute_order_stats(off, min, 
value, max);
                        else if accumulate eq "MAX" then call ci_compute_order_stats(off, min, 
median, value);
                        else if accumulate eq "FIRST" then value=off[1];
                        else if accumulate eq "LAST" then value=off[ec];
                        else if accumulate eq "MODE" then call ci_compute_basic_freq(off, 
count, min, median, max, mean, value);
                        else rc=1;
                        if rc ne 1 then eva[i]=value;
                      end;
                    end;
                                           
                    if rc ne 1 then do;
                      rc=3;
                      if offStart[1]>1 then do;
                        do i=1 to offStart[1]-1;
                          size=size+1;
                          comb[size]=demand[i];
                          combCount[size]=1;
                        end;
                      end;
                      do i=1 to offCount;
                        size=size+1;
                        comb[size]=eva[i];
                        combCount[size]=offEnd[i]-offStart[i]+1;
                        if i<offCount then do;
                          do t=offEnd[i]+1 to offStart[i+1]-1;
                            size=size+1;
                            comb[size]=demand[t];
                            combCount[size]=1;
                          end;
                        end;
                      end;
                      if offEnd[offCount]<msize then do;
                        do i=offEnd[offCount]+1 to msize;
44                                      The SAS System              14:29 Monday, April 9, 2018

                          size=size+1;
                          comb[size]=demand[i];
                          combCount[size]=1;
                        end;
                      end;                      
                      rc=0;
                    end;

                  end;  /*if offCount>0 then do;*/
                  else do;
                    do t=1 to msize;
                      comb[t]=demand[t];
                      combCount[t]=1;
                    end;
                    size=msize;
                  end;                                
                  rc=0;

                  
              endsub;  
              
          
/**********************************************************************************************
*************
              API:
                          ci_compute_profile(demand[*], PeriodStart[*], PeriodEnd[*], 
periodCount, newLen, profile[*]);
              Type:
                          Subroutine
              Purpose: 
                          generate a profile for periods adjusted to the newLen
              Input:   
                         
                          demand            : array that stores the demand series
                          PeriodStart       : array that stores the off season period start 
index value
                          PeriodEnd         : array that stores the off season period end 
index value
                          periodCount       : number of valid elements in PeriodStart and 
PeriodEnd
                          newLen            : the profile length
                          
              Output: 
                          profile           : array that stores the profile

                          
          
***********************************************************************************************
************/
              subroutine ci_compute_profile(demand[*], PeriodStart[*], PeriodEnd[*], 
45                                      The SAS System              14:29 Monday, April 9, 2018

periodCount, newLen, profile[*]);
                  outargs profile;

                  do i=1 to dim(profile); profile[i]=.; end;
                  array newSeries[1] / nosymbols; call dynamic_array(newSeries, newLen);
                  array profileCount[1] / nosymbols; call dynamic_array(profileCount, newLen);
                  do i=1 to newLen; profileCount[i]=0; end;
                  if periodCount>0 then do;
                    do i=1 to periodCount;
                      origLen=PeriodEnd[i]-PeriodStart[i]+1;
                      if origLen ne newLen then do;
                        do j=1 to newLen;
                          newSeries[j]=.;
                          if newLen eq 1 then pos=(PeriodStart[i] +PeriodEnd[i])/2;
                          else pos=PeriodStart[i] +(j-1)*(origLen-1)/(newLen-1);
                          k=floor(pos);
                          if pos eq k then newSeries[j]=demand[k];
                          else newSeries[j]=(k+1-pos)*demand[k]+(pos-k)*demand[k+1];
                        end;
                      end;
                      else do;
                        do j=1 to newLen;
                          k=PeriodStart[i]+j-1;
                          newSeries[j]=demand[k];
                        end;
                      end;
                      do j=1 to newLen;
                        if newSeries[j] ne . then do;
                          profileCount[j]=profileCount[j]+1;
                          if profile[j] ne . then profile[j]=profile[j]+newSeries[j];
                          else profile[j]=newSeries[j];
                        end;
                      end;
                    end;/*do i=1 to periodCount;*/
                    do j=1 to newLen;
                      if profileCount[j]>0 then profile[j]=profile[j]/profileCount[j];
                      else profile[j]=0;
                    end;
                  end;/*if periodCount>0 then do;*/
              endsub;                   

          
/**********************************************************************************************
*************
              API:
                          ci_recover_combine_series(comb[*], combCount[*], combSize, 
accumulate $, profile[*],
                                                    orig[*], origSize, rc);
              Type:
                          Subroutine
46                                      The SAS System              14:29 Monday, April 9, 2018

              Purpose: 
                          Recover the combined series back
              Input:   
                          comb              : array that stores combined series results
                          combCount         : array that stores the number of observations 
corresponding to each element in the combined series
                          combSize          : valid size of the combined series length
                          accumulate        : off season period accumulate method, could be 
TOTAL, AVG, MAX, MED, MIN, FIRST, LAST, MODE
                          profile           : profile for off season periods
                          
              Output: 
                          orig              : recovered original series
                          origSize          : valid size of the recovered original series
                          rc                : return code : 0: success; 1: input array size 
not right; 2: invalid accumulate; 3: others
                          
          
***********************************************************************************************
************/
              subroutine ci_recover_combine_series(comb[*], combCount[*], combSize, accumulate 
$, profile[*],
                                                   orig[*], origSize, rc);
                  outargs orig, origSize, rc;
                  do i=1 to dim(orig); orig[i]=.; end;
                  origSize=0;
                  pLen=dim(profile);
                  rc=1;
                  if pLen>0 and combSize>0 then do;
                    rc=3;
                    do i=1 to combSize;
                      if combCount[i]=1 then do;
                        origSize=origSize+1;
                        orig[origSize]=comb[i];
                      end;
                      else do;
                        array newSeries[1] / nosymbols; call dynamic_array(newSeries, 
combCount[i]);
                        total=0;
                        do j=1 to combCount[i];
                          newSeries[j]=.;
                          pos=1 +(j-1)*(pLen-1)/(combCount[i]-1);
                          k=floor(pos);
                          if pos eq k then newSeries[j]=profile[k];
                          else newSeries[j]=(k+1-pos)*profile[k]+(pos-k)*profile[k+1];
                          total=total+newSeries[j];
                        end;
                        if total=0 then do;
                          do j=1 to combCount[i];
                            newSeries[j]=1/combCount[i];
47                                      The SAS System              14:29 Monday, April 9, 2018

                          end;
                          total=combCount[i];
                        end;
                        call ci_compute_basic_freq(newSeries, count, min, median, max, mean, 
mode);
                        if accumulate = "TOTAL" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]*newSeries[j]/total;
                          end;
                        end;
                        else if accumulate = "AVG" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-mean);
                          end;                        
                        end;
                        else if accumulate = "MAX" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-max);
                          end;                        
                        end;
                        else if accumulate = "MED" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-median);
                          end;                        
                        end;
                        else if accumulate = "MIN" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-min);
                          end;                        
                        end;
                        else if accumulate = "FIRST" then do;
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-newSeries[1]);
                          end;                        
                        end;
                        else if accumulate = "LAST" then do;
                          k=combCount[i];
                          do j=1 to combCount[i];
                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-newSeries[k]);
                          end;                        
                        end;
                        else if accumulate = "MODE" then do;
                          do j=1 to combCount[i];
48                                      The SAS System              14:29 Monday, April 9, 2018

                            origSize=origSize+1;
                            orig[origSize]=comb[i]+(newSeries[j]-mode);
                          end;                        
                        end;
                        else do;
                          rc=2;
                        end;
                        if rc ne 2 then rc=0;
                      end;/*else do for if combCount[i]=1 then do;*/
                    end;/*do i=1 to combSize;*/
                  end;/*if pLen>0 and combSize>0 then do;*/
              endsub;

          
/**********************************************************************************************
*************
              API:
                          ci_find_season_series_seasons(periodStart[*], periodEnd[*], 
periodCount, totObs, inSeasonLen, ssIndex,
                                                        seasonCode[*], rc);
              Type:
                          Subroutine
              Purpose: 
                          Generate season code for a particular event series on a given 
beforeDist and afterDist
              Input:   
                          periodStart       : array that stores the period start index value
                          periodEnd         : array that stores the period end index value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          totObs            : total number of observations
                          inSeasonLen       : in-season period length
                          ssIndex           : relative season start index
                          
              Output: 
                          seasonCode        : array that stores the season code for each 
observation in the demand series
                          rc                : return code : 0: success; 1: periodCount=0; 2: 
invalid ssIndex
                                                            3: invalid periods definition for 
ssIndex; 4: others
                          
          
***********************************************************************************************
************/
              subroutine ci_find_season_series_seasons(periodStart[*], periodEnd[*], 
periodCount, totObs, inSeasonLen, ssIndex,
                                                        seasonCode[*], rc);
                  outargs seasonCode, rc;

49                                      The SAS System              14:29 Monday, April 9, 2018

                  do t=1 to dim(seasonCode); seasonCode[t]=.; end;
                  rc=1;
                  if periodCount>0 then do;
                    rc= 4;
                    array periodPos[1] / nosymbols; call dynamic_array(periodPos, periodCount);
                    array newPeriod[1,2] / nosymbols; call dynamic_array(newPeriod, 
periodCount,2);
                    
                    accM=1;
                    do i=1 to periodCount;
                      options= ci_season_compute_option_count(periodStart, periodEnd, 
periodCount, totObs, inSeasonLen, i);
                      periodPos[i]=mod(ceil(ssIndex/accM), options);
                      if periodPos[i]=0 then periodPos[i]=options;
                      accM=accM*options;
                    end;
                    if ssIndex<=0 or ssIndex>accM then rc=2;
                    else do;
                      rc=4;
                      invalid=0;
                      do i=1 to periodCount;
                        newPeriod[i,1]=.; newPeriod[i,2]=.;
                        if periodEnd[i]<periodStart[i] then invalid=1;
                        if periodEnd[i]-periodStart[i]+1>=inSeasonLen then do;
                          newPeriod[i,1]=periodStart[i]+periodPos[i]-1;
                          newPeriod[i,2]=newPeriod[i,1]+inSeasonLen-1;
                        end;
                        else do;
                          if i>1 then do;
                            newPeriod[i,1]=periodStart[i]-periodPos[i]+1;
                            newPeriod[i,2]=newPeriod[i,1]+inSeasonLen-1;                       
     
                          end;
                          else do;
                            newPeriod[i,2]=periodEnd[i]+periodPos[i]-1;
                            newPeriod[i,1]=newPeriod[i,2]-inSeasonLen+1;
                          end;
                        end;
                        if i>1 then do;
                          if newPeriod[i,1]<=newPeriod[i-1,2]+1 then invalid=1;
                        end;
                      end;
                      if invalid = 1 then rc=3;
                      else do;
                        do i=1 to totObs;
                          seasonCode[i]=0;
                        end;
                        do i=1 to periodCount;
                          do j=newPeriod[i,1] to newPeriod[i,2];
                            if j>0 and j<=totObs then seasonCode[j]=j-newPeriod[i,1]+1;
50                                      The SAS System              14:29 Monday, April 9, 2018

                          end;
                        end;
                        rc=0;
                      end; /*else for if invalid = 1*/
                    end; /*else for if ssIndex<=0 or ssIndex>accM */
                  end;/*if periodCount>0 then do;*/
                  

                  
              endsub;              

          
/**********************************************************************************************
*************
              API:
                          ci_find_season_start_index(periodStart[*], periodCount, 
seasonIndex[*], inSeasonRule $);
              Type:
                          function
              Purpose: 
                          Derive in-season start index based on previous history and rule
              Input:   
                          periodStart       : array that stores the period start index value
                          periodCount       : number of valid elements in periodStart and 
periodEnd
                          seasonIndex       : array that stores the season indices
                          inSeasonRule      : rule used to find in season start index, 
possible values are MIN, MAX, MEAN, MODE, MED, LAST
              Output: 
                          the expected season start index
                          
          
***********************************************************************************************
************/
              function ci_find_season_start_index(periodStart[*], periodCount, seasonIndex[*], 
inSeasonRule $);
                  start=.;
                  if periodCount>0 then do;
                    off=0;
                    call ci_compute_order_stats(seasonIndex, _INDEX_MIN, _INDEX_MED, 
_INDEX_MAX);
                    array periodSIndex[1] / nosymbols; call dynamic_array(periodSIndex, 
periodCount);
                    do i=1 to periodCount;
                      j=periodStart[i];
                      periodSIndex[i]=seasonIndex[j];
                    end;
                    call ci_compute_basic_freq(periodSIndex, _START_COUNT, _START_MIN, 
_START_MEDIAN, _START_MAX,
                                               _START_MEAN, _START_MODE);
51                                      The SAS System              14:29 Monday, April 9, 2018

                    /*adjustment for going across cycles*/
                    if _START_MAX-_START_MIN>_START_MIN+_INDEX_MAX-_START_MAX then do;
                      off=1;
                      array newPeriodStart[1] / nosymbols; 
                      call dynamic_array(newPeriodStart, periodCount);
                      do i=1 to periodCount;
                        if periodSIndex[i]-_START_MIN>=_START_MAX-periodSIndex[i] then do;
                          newPeriodStart[i]=periodSIndex[i];
                        end;
                        else newPeriodStart[i]=periodSIndex[i]+_INDEX_MAX;
                      end;
                      call ci_compute_basic_freq(newPeriodStart, _START_COUNT, _START_MIN, 
_START_MEDIAN, _START_MAX,
                                                 _START_MEAN, _START_MODE);
                    end;
                    if inSeasonRule eq "MIN" then start=_START_MIN;
                    else if inSeasonRule eq "MAX" then start=_START_MAX;
                    else if inSeasonRule eq "MEAN" then start=floor(_START_MEAN);
                    else if inSeasonRule eq "MODE" then start=_START_MODE;
                    else if inSeasonRule eq "MED" then start=floor(_START_MEDIAN);
                    else do;
                      start=periodSIndex[periodCount];
                    end;
                    if start>_INDEX_MAX then start=start-_INDEX_MAX;
                  end;
                  return(start);
                  
              endsub;  
                          
              
              
/**********************************************************************************************
*************
              API:
                          ci_season_compute_next_period_distance(interval $, currentDate, 
currentIndex, startIndex, seasonality);
              Type:
                          function
              Purpose: 
                          compute the distance to the next inseason period
              Input:   
                          interval          : time interval
                          currentDate       : the current date
                          currentIndex      : the season index for the last(current) 
observation
                          startIndex        : the next season starting index      
                          seasonality       : season cycle length  
                          
              Output: 
                          dist
52                                      The SAS System              14:29 Monday, April 9, 2018

                          
          
***********************************************************************************************
************/
              function ci_season_compute_next_period_distance(interval $, currentDate, 
currentIndex, startIndex, seasonality);
                  dist=.;
                  if startIndex> currentIndex then temp_dist=startIndex-currentIndex;
                  else temp_dist=startIndex-currentIndex+seasonality;
                  
                  if interval ne "" and INTSEAS(interval)=seasonality then do;
                    do i=-2 to 2;
                      nextDate=INTNX(interval,currentDate,temp_dist+i);
                      if INTINDEX(interval, nextDate, seasonality) eq startIndex then 
dist=INTCK(interval, currentDate, nextDate); 
                    end;
                  end;
                  else dist=temp_dist;

                  return(dist);
              endsub;
              
          
/**********************************************************************************************
*************
              API:
                          ci_compute_trail_missing_length(series[*], totObs);
              Type:
                          function
              Purpose: 
                          compute the trailing missing period length
              Input:   
                          series            : array that stores the series
                          totObs            : total number of observations need to consider 
              Output: 
                          len
                          
          
***********************************************************************************************
************/
              function ci_compute_trail_missing_length(series[*], totObs);
                  len=0;
                  if series[totObs] eq . then do;
                    flag=0;
                    do i=1 to totObs;
                      j=totObs-i+1;
                      if series[j] ne . and flag eq 0 then do;
                        flag =1;
                        len=i-1;
                      end;
53                                      The SAS System              14:29 Monday, April 9, 2018

                    end;
                  end;

                  return(len);
              endsub;              

          
/**********************************************************************************************
*************
              API:
                          ci_generate_forecast_one(demand[*], season_code[*], totObs, leadLen, 
trailLen, expectTrailLen, inLen, 
                                                   offSeasonRule $, idForecastMethod $, 
idForecastAccum $, idForecastMode $, sign $,
                                                   forecastCriterion $, repositoryNm $, 
diagEstNm $, indataset $, outdataset $,
                                                   _outForecast[*], outsize, rc);
              Type:
                          Subroutine
              Purpose: 
                          Generate forecast for a given series with season code, etc 
information available
              Input:   
                          demand            : array that stores the series for forecast
                          season_code       : array that stores the season code for the demand 
series
                          totObs            : total number of observations
                          leadLen           : leading off-season period length
                          trailLen          : trailing off-season period length
                          expectTrailLen    : expected trailing off-season whole period length
                          inLen             : in-season period length
                          offSeasonRule     : rule used to find off season length, possible 
values are MIN, MAX, MEAN, MODE, MEDIAN, LAST
                          idForecastMethod  : method used for forecast, possible values are 
ACCUMULATE or SEPARATE
                          idForecastAccum:  : accumulation method used to accumulate the 
off-season period observations when forecast method is ACCUMULATE, 
                                              possible values are "TOTAL", "AVG", "MIN", 
"MED", "MAX", "FIRST", "LAST", "MODE"
                          idForecastMode    : mode used for generating forecast, possible 
values are "ALL" (for HPF), "AVG" (for using average profile forecast)
                          sign              : the sign for forecast values, possible values 
are "MIXED", "NONNEGATIVE", "NONPOSITIVE"
                          forecastCriterion : criterion for selecting forecast model, possible 
values are "MAPE", "MAE", "MSE"
                          repositoryNm      : catalog location and name for the model 
repository, only used when idForecastMode is "ALL"
                          diagEstNm         : location and name for the diagnose estimation 
results, only used when idForecastMode is "ALL"
                          indataset         : location and name the to-forecast series should 
54                                      The SAS System              14:29 Monday, April 9, 2018

be written to, only used when idForecastMode is "ALL"
                          outdataset        : location and name the HPF forecast results 
should be written to, only used when idForecastMode is "ALL"
                          
              Output: 
                          _outForecast      : array that stores the forecast results
                          outsize           : size of valid forecast elements
                          rc                : return code : 0: success; 
                          
          
***********************************************************************************************
************/
              subroutine ci_generate_forecast_one(demand[*], season_code[*], totObs, leadLen, 
trailLen, expectTrailLen, inLen, 
                                                  offSeasonRule $, idForecastMethod $, 
idForecastAccum $, idForecastMode $, sign $,
                                                  forecastCriterion $, repositoryNm $, 
diagEstNm $, indataset $, outdataset $,
                                                  _outForecast[*], outsize, rc);

                  outargs _outForecast, outsize, rc;
                  
                  rc=0;
                  outsize=dim(_outForecast);
                  do i=1 to outsize; _outForecast[i]=.; end;

                  array offStart[1]/NOSYMBOLS; call dynamic_array(offStart, totObs); 
                  array offEnd[1]/NOSYMBOLS; call dynamic_array(offEnd, totObs); 
                 
                  if expectTrailLen>0 and expectTrailLen ne trailLen then do;
                    removeTrail=1;
                    call ci_find_off_periods_by_code(season_code, 0, 0, offStart, offEnd, 
offCount);
                    trimObs=totObs-trailLen;
                    newTotObs=totObs+expectTrailLen-trailLen;
                  end;
                  else do;
                    removeTrail=0;
                    call ci_find_off_periods_by_code(season_code, 0, 1, offStart, offEnd, 
offCount);
                    trimObs=totObs;
                    newTotObs=totObs;
                  end;
                  array trimDemand[1]/NOSYMBOLS; call dynamic_array(trimDemand, trimObs); 
                  do i=1 to trimObs;
                    if i<=leadLen then trimDemand[i]=.;
                    else trimDemand[i]=demand[i];
                  end;   
                  trailMissLen=ci_compute_trail_missing_length(demand, totObs);           
                  newLen=ci_find_off_periods_length(offStart, offEnd, offCount, offSeasonRule, 
55                                      The SAS System              14:29 Monday, April 9, 2018

totObs-trailMissLen);
                  array _combOrigFSeries[1]/NOSYMBOLS; call dynamic_array(_combOrigFSeries, 
newTotObs);

                  if idForecastMethod = "ACCUMULATE" then do;
                    array _combSeries[1]/NOSYMBOLS; call dynamic_array(_combSeries, trimObs);
                    array _combCount[1]/NOSYMBOLS; call dynamic_array(_combCount, trimObs);
                    call ci_combine_series_season(trimDemand, season_code, idForecastAccum, 
_combSeries, _combCount, combTotCount, tmp_rc);
                    if removeTrail=1 then lead=1;
                    else lead=0;
                    trailMissLen=ci_compute_trail_missing_length(_combSeries, combTotCount);
                    newCount=combTotCount-trailMissLen;
                    array _toForecast[1]/NOSYMBOLS; call dynamic_array(_toForecast, newCount); 
                    do i=1 to newCount; _toForecast[i]=_combSeries[i]; end;
                    array _fcst[1]/NOSYMBOLS; call dynamic_array(_fcst, combTotCount); 
                    array _fcstCount[1]/NOSYMBOLS; call dynamic_array(_fcstCount, 
combTotCount);
                    do i=1 to combTotCount; _fcstCount[i]=_combCount[i]; end;
                    if removeTrail=1 then _fcstCount[combTotCount] = expectTrailLen;
                    lead=lead+trailMissLen;

                    if idForecastMode = "ALL" then do;
                      array _toTimeID[1]/NOSYMBOLS; call dynamic_array(_toTimeID, newCount); 
                      array _fTimeID[1]/NOSYMBOLS; call dynamic_array(_fTimeID, 
newCount+lead); 
                      do i=1 to newCount; _toTimeID[i]=i; end;
                      
                      call ci_run_forecast(_toForecast, _toTimeID, "DAY", inLen+1, lead, sign, 
forecastCriterion, 
                                           repositoryNm, diagEstNm, indataset, 
outdataset,_fcst,_fTimeID, tmp_rc);
                    end; 
                    else do;
                      call ci_run_forecast2(_toForecast, inLen+1, lead, sign, _fcst);
                      if leadLen>0 then _fcst[1]=.;
                    end;

                    array offProfile[1]/NOSYMBOLS; call dynamic_array(offProfile, newLen); 
                    call ci_compute_profile(trimDemand, offStart, offEnd, offCount, newLen, 
offProfile);
                    call ci_recover_combine_series(_fcst, _fcstCount, combTotCount, 
idForecastAccum, offProfile,
                                                   _combOrigFSeries, origSize, tmp_rc);
                    if origSize<outsize then outsize=origSize;
                    do i=1 to outsize;
                      if i<=leadLen then _outForecast[i]=.;
                      else _outForecast[i]=_combOrigFSeries[i];
                    end;
                  end; /*if idForecastMethod = "ACCUMULATE" then do;*/
56                                      The SAS System              14:29 Monday, April 9, 2018

                  else do;
                    array newSeries[1]/NOSYMBOLS; call dynamic_array(newSeries, 
totObs+(offCount+1)*newLen); 
                    array newPeriodStart[1]/NOSYMBOLS; call dynamic_array(newPeriodStart, 
offCount+2); 
                    array newPeriodEnd[1]/NOSYMBOLS; call dynamic_array(newPeriodEnd, 
offCount+2); 
                    
                    if leadLen>0 then do;
                      if removeTrail=1 then call ci_find_off_periods_by_code(season_code, 1, 
0, offStart, offEnd, offCount);
                      else call ci_find_off_periods_by_code(season_code, 1, 1, offStart, 
offEnd, offCount);
                    end;
                    call ci_stretch_squeeze_series(trimDemand, offStart, offEnd, offCount, 
newLen, 
                                                   newPeriodStart, newPeriodEnd, newSeries, 
newCount, tmp_rc);
                    offTotObs=newLen*offCount;                               
                    if removeTrail = 1 then offLead=newLen;
                    else offLead=0;
                    combTotObs=newCount+offLead;
                    inLead=0;
                    inTotObs=newCount-offTotObs;
                    trailMissLen=ci_compute_trail_missing_length(newSeries, newCount);
                    if trailMissLen>0 then do;
                      offMissCount=0;
                      do i=1 to offCount;
                        do j=newPeriodStart[i] to newPeriodEnd[i];
                          if j>newCount-trailMissLen then offMissCount=offMissCount+1;
                        end;
                      end;
                      inLead=trailMissLen-offMissCount;
                      offLead=offLead+offMissCount;
                      inTotObs=inTotObs-inLead;
                      offTotObs=offTotObs-offMissCount;
                    end;

                    array _inSeries[1]/NOSYMBOLS; call dynamic_array(_inSeries, inTotObs);
                    array _inFcst[1]/NOSYMBOLS; call dynamic_array(_inFcst, inTotObs+inLead); 
                    array _offSeries[1]/NOSYMBOLS; call dynamic_array(_offSeries, offTotObs); 
                    array _offFcst[1]/NOSYMBOLS; call dynamic_array(_offFcst, 
offTotObs+offLead); 
                    
                    call ci_split_series_by_period(newSeries, newCount-trailMissLen, 
newPeriodStart, newPeriodEnd, offCount,
                                                   _inSeries, _offSeries, inIndex, offIndex);  
                                
                    if idForecastMode = "ALL" then do;
                      array _inTimeID[1]/NOSYMBOLS; call dynamic_array(_inTimeID, inTotObs); 
57                                      The SAS System              14:29 Monday, April 9, 2018

                      array _inFTimeID[1]/NOSYMBOLS; call dynamic_array(_inFTimeID, inTotObs); 
                      array _offTimeID[1]/NOSYMBOLS; call dynamic_array(_offTimeID, 
offTotObs); 
                      array _offFTimeID[1]/NOSYMBOLS; call dynamic_array(_offFTimeID, 
offTotObs); 
                      do i=1 to inTotObs; _inTimeID[i]=i; end;
                      do i=1 to offTotObs; _offTimeID[i]=i; end;
                      call ci_run_forecast(_inSeries, _inTimeID, "DAY", inLen, inLead, sign, 
forecastCriterion, 
                                           repositoryNm, diagEstNm, indataset, 
outdataset,_inFcst,_inFTimeID, tmp_rc);
                      call ci_run_forecast(_offSeries, _offTimeID, "DAY", newLen, offLead, 
sign, forecastCriterion, 
                                           repositoryNm, diagEstNm, indataset, 
outdataset,_offFcst,_offFTimeID, tmp_rc);                           
                    end; 
                    else do;
                      call ci_run_forecast2(_inSeries, inLen, inLead, sign, _inFcst);
                      call ci_run_forecast2(_offSeries, newLen, offLead, sign, _offFcst);
                      if leadLen>0 then do;
                        do i=1 to newLen;
                          _offFcst[i]=.;
                        end;
                      end;
                    end;

                    if removeTrail = 1 then do; 
                      offCount=offCount+1;
                      newPeriodStart[offCount]=newCount+1;
                      newPeriodEnd[offCount]=combTotObs;
                      offStart[offCount]=totObs-trailLen+1;
                      offEnd[offCount]=offStart[offCount]+expectTrailLen-1;
                    end;

                    array _combSeries[1]/NOSYMBOLS; call dynamic_array(_combSeries, 
combTotObs);
                    call ci_combine_two_series_by_period(_inFcst, _offFcst, combTotObs, 
newPeriodStart, newPeriodEnd, offCount,
                                                         _combSeries, inIndex, offIndex, 
combIndex);

                    call ci_recover_stretch_squeeze_series(newPeriodStart, newPeriodEnd, 
_combSeries, combTotObs,newLen,
                                                           offStart, offEnd, offCount, 
_combOrigFSeries, origSize, tmp_rc);
                    if origSize<outsize then outsize=origSize;
                    lastMissId=0;
                    do i=1 to outsize;
                      if i<=leadLen then _outForecast[i]=.;
                      else _outForecast[i]=_combOrigFSeries[i];
58                                      The SAS System              14:29 Monday, April 9, 2018

                      if _outForecast[i] eq . and i>lastMissId then lastMissId=i;
                    end;
                    if lastMissId>0 then do;
                      do i=1 to lastMissId;
                        _outForecast[i]=.;
                      end;
                    end; 
                  end; /*else do for if idForecastMethod = "ACCUMULATE" then do;*/

                  
              endsub;              

          
/**********************************************************************************************
*************
              API:
                          ci_season_find_trim_info(timeID[*], season_code[*], season_index[*], 
totObs, interval $, seasonality, seasonStart, 
                                                   leadLen, trailLen, expectTrailLen, rc);
              Type:
                          subroutine
              Purpose: 
                          find the leading trailing information about the seasonal series
              Input:   
                          timeID            : array that stores the time ID series
                          season_code       : array that stores the season code for the demand 
series
                          season_index      : array that stores the season index for each 
observations
                          totObs            : total number of observations
                          interval          : time interval
                          seasonality       : seasonal cycle length
                          seasonStart       : in-season start index   
              Output: 
                          leadLen           : leading off-season period length
                          trailLen          : trailing off-season period length
                          expectTrailLen    : expected trailing off-season whole period length 
 
                          rc                : return code : 0: success; 1: input arrays size 
incorrect                     
                          
          
***********************************************************************************************
************/
              subroutine ci_season_find_trim_info(timeID[*], season_code[*], season_index[*], 
totObs, interval $, seasonality, seasonStart, 
                                                  leadLen, trailLen, expectTrailLen, rc);
                  outargs leadLen, trailLen, expectTrailLen, rc;
                  leadLen=0;
                  trailLen=0;
59                                      The SAS System              14:29 Monday, April 9, 2018

                  expectTrailLen=0;
                  rc=0;
                  if dim(timeID)<totObs or dim(season_code)<totObs or dim(season_index)<totObs 
then rc=1;
                  else do;
                  
                    if season_code[1]=0 or season_code[totObs]=0 then do;
                      array offStart[1]/NOSYMBOLS; call dynamic_array(offStart, totObs); 
                      array offEnd[1]/NOSYMBOLS; call dynamic_array(offEnd, totObs); 
                      call ci_find_off_periods_by_code(season_code, 1, 1, offStart, offEnd, 
offCount);
                      if offStart[1]=1 then leadLen=offEnd[1];
                      if offEnd[offCount]=totObs then 
trailLen=offEnd[offCount]-offStart[offCount]+1;
                      if trailLen>0 then do;
                        expectTrailLen=ci_season_compute_next_period_distance(interval, 
timeID[totObs-trailLen+1], season_index[totObs-trailLen+1], seasonStart, seasonality);
                        if expectTrailLen eq . then expectTrailLen=trailLen;
                      end;
                    end;
                  end;
                  
              endsub; 

          
/**********************************************************************************************
*************
              API:
                          ci_event_find_trim_info(timeID[*], season_code[*], eventDate[*], 
totObs, eventCount, interval $, beforeDist, 
                                                  leadLen, trailLen, expectTrailLen, rc);
              Type:
                          subroutine
              Purpose: 
                          find the leading trailing information about the event series
              Input:   
                          timeID            : array that stores the time ID series
                          season_code       : array that stores the season code for the demand 
series
                          eventDate         : array that stores the event dates for the 
particular eventIdx that matters
                          totObs            : total number of observations
                          eventCount        : number of observations in the eventDate
                          interval          : time interval
                          beforeDist        : the number of periods each in-season periods 
starts compared with event date
              Output: 
                          leadLen           : leading off-season period length
                          trailLen          : trailing off-season period length
                          expectTrailLen    : expected trailing off-season whole period length 
60                                      The SAS System              14:29 Monday, April 9, 2018

                          rc                : return code : 0: success; 1: input arrays size 
incorrect; eventCount=0;                     
                          
          
***********************************************************************************************
************/
              subroutine ci_event_find_trim_info(timeID[*], season_code[*], eventDate[*], 
totObs, eventCount, interval $, beforeDist, 
                                                 leadLen, trailLen, expectTrailLen, rc);
                  outargs leadLen, trailLen, expectTrailLen, rc;
                  leadLen=0;
                  trailLen=0;
                  expectTrailLen=0;
                  rc=0;
                  if eventCount<1 then rc=2;
                  else if dim(timeID)<totObs or dim(season_code)<totObs then rc=1;
                  else do;
                    if season_code[1]=0 or season_code[totObs]=0 then do;
                      array offStart[1]/NOSYMBOLS; call dynamic_array(offStart, totObs); 
                      array offEnd[1]/NOSYMBOLS; call dynamic_array(offEnd, totObs); 
                      call ci_find_off_periods_by_code(season_code, 1, 1, offStart, offEnd, 
offCount);
                      if offStart[1]=1 then leadLen=offEnd[1];
                      if offEnd[offCount]=totObs then 
trailLen=offEnd[offCount]-offStart[offCount]+1;
                      if trailLen>0 then do;
                        expectTrailLen=ci_event_compute_next_period_distance(eventDate, 
eventCount, interval, timeID[totObs-trailLen+1], beforeDist);
                        if expectTrailLen eq . then expectTrailLen=trailLen;
                      end;
                    end;
                  end; 
                  
              endsub;  
              
              
              
/**********************************************************************************************
*************
              API:
                          ci_season_compute_option_count(allPeriodStart[*], allPeriodEnd[*], 
allPeriodCount, totObs, sl, t);
              Type:
                          function
              Purpose: 
                          compute the number of candidate options for the current period (t)
              Input:   
                          allPeriodStart    : array that stores the period start index
                          allPeriodEnd      : array that stores the period end index
                          allPeriodCount    : count of valid element size in both 
61                                      The SAS System              14:29 Monday, April 9, 2018

allPeriodStart and allPeriodEnd
                          totObs            : total number of observations
                          sl                : season length   
                          t                 : current period index
                          
              Output: 
                          options
                          
          
***********************************************************************************************
************/
              function ci_season_compute_option_count(allPeriodStart[*], allPeriodEnd[*], 
allPeriodCount, totObs, sl, t);
              
                  options=1;
                  array allPeriodRange[1]/NOSYMBOLS; call dynamic_array(allPeriodRange, 
allPeriodCount); 
                  do i=1 to allPeriodCount;
                    allPeriodRange[i]=allPeriodEnd[i]-allPeriodStart[i]+1; 
                  end;
                  options = abs(allPeriodRange[t]-sl)+1;
                  if allPeriodRange[t]<sl then do;
                    if t>1 then do;
                      if allPeriodRange[t-1]<=sl then minEnd=allPeriodEnd[t-1];
                      else minEnd=allPeriodStart[t-1]+sl-1;
                      if allPeriodStart[t]-minEnd-1<options then 
options=allPeriodStart[t]-minEnd-1;
                      if t eq allPeriodCount and t>2 and allPeriodEnd[t] eq totObs then do;
                        /*for partial trailing cycle, only keep the reasonable solutions, not 
comprehensive ones*/
                        minOff=allPeriodEnd[t];
                        do i=1 to t-1; 
                          if allPeriodStart[i+1]-allPeriodEnd[i]<minOff then 
minOff=allPeriodStart[i+1]-allPeriodEnd[i];
                        end;
                        if options>allPeriodStart[t]-(allPeriodEnd[t-1]+minOff)+1 then do;
                          options=allPeriodStart[t]-(allPeriodEnd[t-1]+minOff)+1;
                        end;
                      end;
                    end;
                    else if allPeriodCount>2 and allPeriodStart[1]=1 then do;
                      if allPeriodRange[2]>sl then maxStart=allPeriodEnd[2]-sl+1;
                      else maxStart=allPeriodStart[2];
                      if maxStart-allPeriodEnd[1]-1<options then 
options=maxStart-allPeriodEnd[1]-1;
                      minOff=allPeriodEnd[allPeriodCount];;
                      do i=2 to allPeriodCount;
                        if allPeriodStart[i]-allPeriodEnd[i-1]<minOff then 
minOff=allPeriodStart[i]-allPeriodEnd[i-1];
                      end;
62                                      The SAS System              14:29 Monday, April 9, 2018

                      /*for partial leading cycle, only keep the reasonable solutions, not 
comprehensive ones*/
                      if options>allPeriodStart[2]-minOff-allPeriodEnd[1]+1 then do;
                        options=allPeriodStart[2]-minOff-allPeriodEnd[1]+1;
                      end;
                    end;
                  end;
                  if options<1 then options=1;

                  return(options);
              endsub;              
                                                                                   
          run; 
          quit;
      %end; 
  %mend;
  %ci_fcmp_functions(cmpLib=_ciTmp.ciFuncs);         
      
MPRINT(CI_FCMP_FUNCTIONS):   proc fcmp ENCRYPT HIDE outlib=_ciTmp.ciFuncs.funcs;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_sum(timedata[*], sum, count);
MPRINT(CI_FCMP_FUNCTIONS):   outargs sum, count;
MPRINT(CI_FCMP_FUNCTIONS):   sum = .;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   length=dim(timedata);
MPRINT(CI_FCMP_FUNCTIONS):   if length>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   sum=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to length;
MPRINT(CI_FCMP_FUNCTIONS):   if timedata[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   sum = sum + timedata[i];
MPRINT(CI_FCMP_FUNCTIONS):   count = count+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if count=0 then sum=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_mean(timedata[*], mean, count);
MPRINT(CI_FCMP_FUNCTIONS):   outargs mean, count;
MPRINT(CI_FCMP_FUNCTIONS):   mean = .;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   length=dim(timedata);
MPRINT(CI_FCMP_FUNCTIONS):   if length>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_sum(timedata, sum, count);
MPRINT(CI_FCMP_FUNCTIONS):   if count>0 and sum ne . then mean = sum / count;
3                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_order_stats(timedata[*], min, median, max);
MPRINT(CI_FCMP_FUNCTIONS):   outargs min, median, max;
MPRINT(CI_FCMP_FUNCTIONS):   array order[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   min = .;
MPRINT(CI_FCMP_FUNCTIONS):   median = .;
MPRINT(CI_FCMP_FUNCTIONS):   max = .;
MPRINT(CI_FCMP_FUNCTIONS):   length=dim(timedata);
MPRINT(CI_FCMP_FUNCTIONS):   if length>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(order, length);
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to length;
MPRINT(CI_FCMP_FUNCTIONS):   if timedata[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   count = count+1;
MPRINT(CI_FCMP_FUNCTIONS):   order[count]=timedata[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if count>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if count=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   min = order[1];
MPRINT(CI_FCMP_FUNCTIONS):   median = order[1];
MPRINT(CI_FCMP_FUNCTIONS):   max = order[1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to count-1;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to count-1;
MPRINT(CI_FCMP_FUNCTIONS):   if order[j]>order[j+1] then do;
MPRINT(CI_FCMP_FUNCTIONS):   temp = order[j];
MPRINT(CI_FCMP_FUNCTIONS):   order[j]=order[j+1];
MPRINT(CI_FCMP_FUNCTIONS):   order[j+1]=temp;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   min=order[1];
MPRINT(CI_FCMP_FUNCTIONS):   max=order[count];
MPRINT(CI_FCMP_FUNCTIONS):   index=floor(count/2);
MPRINT(CI_FCMP_FUNCTIONS):   if index*2<count then median = order[index+1];
MPRINT(CI_FCMP_FUNCTIONS):   else median = (order[index]+order[index+1])/2;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_basic_freq(timedata[*], count, min, median, max, mean, mode);
MPRINT(CI_FCMP_FUNCTIONS):   outargs count, min, median, max, mean, mode;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   min=.;
MPRINT(CI_FCMP_FUNCTIONS):   median=.;
MPRINT(CI_FCMP_FUNCTIONS):   max=.;
MPRINT(CI_FCMP_FUNCTIONS):   mean=.;
4                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   mode=.;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_order_stats(timedata, min, median, max);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_mean(timedata, mean, count);
MPRINT(CI_FCMP_FUNCTIONS):   array freq[1,1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(freq, count,2);
MPRINT(CI_FCMP_FUNCTIONS):   fcount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(timedata);
MPRINT(CI_FCMP_FUNCTIONS):   if timedata[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   if fcount=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   fcount=fcount+1;
MPRINT(CI_FCMP_FUNCTIONS):   freq[fcount,1]=timedata[i];
MPRINT(CI_FCMP_FUNCTIONS):   freq[fcount,2]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   found=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to fcount;
MPRINT(CI_FCMP_FUNCTIONS):   if freq[j,1]=timedata[i] then do;
MPRINT(CI_FCMP_FUNCTIONS):   found=1;
MPRINT(CI_FCMP_FUNCTIONS):   freq[j,2]=freq[j,2]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if found eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   fcount=fcount+1;
MPRINT(CI_FCMP_FUNCTIONS):   freq[fcount,1]=timedata[i];
MPRINT(CI_FCMP_FUNCTIONS):   freq[fcount,2]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if fcount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   modeC=freq[1,2];
MPRINT(CI_FCMP_FUNCTIONS):   mode = freq[1,1];
MPRINT(CI_FCMP_FUNCTIONS):   if fcount>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=2 to fcount;
MPRINT(CI_FCMP_FUNCTIONS):   if freq[i,2]>=modeC then do;
MPRINT(CI_FCMP_FUNCTIONS):   modeC=freq[i,2];
MPRINT(CI_FCMP_FUNCTIONS):   mode = freq[i,1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_active_period_range(activeDemand[*],firstPartialFlag, lastPartialFlag, periodStart[*], periodEnd[*], periodCount, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs periodStart, periodEnd, periodCount, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(periodStart);
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(periodEnd);
5                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 1;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(periodStart) eq dim(periodEnd) then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 2;
MPRINT(CI_FCMP_FUNCTIONS):   size=dim(activeDemand);
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[1] ne . and firstPartialFlag=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=1;
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[2] eq . then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1+1 to size-1;
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[i] ne . and activeDemand[i-1] eq . then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[i] ne . and activeDemand[i+1] eq . then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[size] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   i=size;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount = periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if activeDemand[i-1] eq . then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if lastPartialFlag ne 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_offseason_period_range(periodStart[*], periodEnd[*], periodCount, demandSize, firstPartialFlag, lastPartialFlag, offStart[*], offEnd[*], offCount, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs offStart, offEnd, offCount, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(offStart);
6                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   offStart[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(offEnd);
MPRINT(CI_FCMP_FUNCTIONS):   offEnd[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 1;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(offStart) eq dim(offEnd) then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 2;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = 0;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if firstPartialFlag eq 1 or lastPartialFlag eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=1;
MPRINT(CI_FCMP_FUNCTIONS):   offEnd[offCount]=demandSize;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   tmpIndex = 1;
MPRINT(CI_FCMP_FUNCTIONS):   if periodStart[1] eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]= periodEnd[1]+1;
MPRINT(CI_FCMP_FUNCTIONS):   tmpIndex=2;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if firstPartialFlag eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]= 1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount>=tmpIndex then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=tmpIndex to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then offEnd[offCount]=periodStart[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=periodEnd[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if periodEnd[periodCount] lt demandSize and lastPartialFlag eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then offEnd[offCount]=demandSize;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   offCount = offCount-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_active_event(activeDemand[*], timeID[*], eventFile $, eventSize, interval $, eventDefBufferLen, eventIdx, rc);
7                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   outargs eventIdx, rc;
MPRINT(CI_FCMP_FUNCTIONS):   eventIdx = .;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 1;
MPRINT(CI_FCMP_FUNCTIONS):   if eventSize>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=5;
MPRINT(CI_FCMP_FUNCTIONS):   demandSize = dim(activeDemand);
MPRINT(CI_FCMP_FUNCTIONS):   if demandSize ne dim(timeID) then rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   array tmp[1,1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(tmp, eventSize, 3);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   tmp[t,1]=.;
MPRINT(CI_FCMP_FUNCTIONS):   tmp[t,2]=.;
MPRINT(CI_FCMP_FUNCTIONS):   tmp[t,3]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   temp_rc = read_array(eventFile, tmp, 'event_idx' , 'event_date', 'weight');
MPRINT(CI_FCMP_FUNCTIONS):   if temp_rc=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array periodStart[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   array periodEnd[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(periodStart, demandSize);
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(periodEnd, demandSize);
MPRINT(CI_FCMP_FUNCTIONS):   array offStart[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   array offEnd[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_active_period_range(activeDemand, 1, 1, periodStart, periodEnd, periodCount, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount >0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array eventList[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(eventList, eventSize);
MPRINT(CI_FCMP_FUNCTIONS):   eventCount = 0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   if eventCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[i,1] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   found=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[i,1] eq eventList[j] then found=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if found eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   eventCount = eventCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   eventList[eventCount]=tmp[i,1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[i,1] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   eventCount = 1;
MPRINT(CI_FCMP_FUNCTIONS):   eventList[eventCount]=tmp[i,1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array candiList[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(candiList, eventCount);
8                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   candiSize=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   candiList[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   event=eventList[i];
MPRINT(CI_FCMP_FUNCTIONS):   out=0;
MPRINT(CI_FCMP_FUNCTIONS):   do k=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   found=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[j,1] eq event then do;
MPRINT(CI_FCMP_FUNCTIONS):   s=periodStart[k];
MPRINT(CI_FCMP_FUNCTIONS):   e=periodEnd[k];
MPRINT(CI_FCMP_FUNCTIONS):   bc = INTCK( interval, timeID[s], tmp[j,2]);
MPRINT(CI_FCMP_FUNCTIONS):   ac = INTCK( interval, tmp[j,2], timeID[e]);
MPRINT(CI_FCMP_FUNCTIONS):   if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then found=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if found eq 0 and not ((k=1 and periodStart[k]=1) or (k=periodCount and periodEnd[k]=demandSize)) then out=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if out eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   candiSize=candiSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   candiList[candiSize]=event;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if candiSize eq 1 then eventIdx=candiList[1];
MPRINT(CI_FCMP_FUNCTIONS):   else if candiSize > 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array weightList[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(weightList, candiSize);
MPRINT(CI_FCMP_FUNCTIONS):   maxWeight=.;
MPRINT(CI_FCMP_FUNCTIONS):   array distList[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(distList, candiSize);
MPRINT(CI_FCMP_FUNCTIONS):   array beforeDist[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   array afterDist[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(beforeDist, eventSize);
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(afterDist, eventSize);
MPRINT(CI_FCMP_FUNCTIONS):   minDist=.;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to candiSize;
MPRINT(CI_FCMP_FUNCTIONS):   event=candiList[i];
MPRINT(CI_FCMP_FUNCTIONS):   weightList[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   distList[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   beforeDist[j]=.;
MPRINT(CI_FCMP_FUNCTIONS):   afterDist[j]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   dCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   beforeDistMean=.;
MPRINT(CI_FCMP_FUNCTIONS):   afterDistMean=.;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[j,1] eq event then do;
9                                                                                                                        The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   do k=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   s=periodStart[k];
MPRINT(CI_FCMP_FUNCTIONS):   e=periodEnd[k];
MPRINT(CI_FCMP_FUNCTIONS):   bc = INTCK( interval, timeID[s], tmp[j,2]);
MPRINT(CI_FCMP_FUNCTIONS):   ac = INTCK( interval, tmp[j,2], timeID[e]);
MPRINT(CI_FCMP_FUNCTIONS):   if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   if weightList[i] ne . then weightList[i]=weightList[i]+tmp[j,3];
MPRINT(CI_FCMP_FUNCTIONS):   else weightList[i]=weightList[i];
MPRINT(CI_FCMP_FUNCTIONS):   dCount=dCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   beforeDist[dCount]=bc;
MPRINT(CI_FCMP_FUNCTIONS):   afterDist[dCount]=ac;
MPRINT(CI_FCMP_FUNCTIONS):   if beforeDistMean ne . then beforeDistMean=beforeDistMean+beforeDist[dCount];
MPRINT(CI_FCMP_FUNCTIONS):   else beforeDistMean=beforeDist[dCount];
MPRINT(CI_FCMP_FUNCTIONS):   if afterDistMean ne . then afterDistMean=afterDistMean+afterDist[dCount];
MPRINT(CI_FCMP_FUNCTIONS):   else afterDistMean=afterDist[dCount];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if weightList[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   weightList[i]=weightList[i]/dCount;
MPRINT(CI_FCMP_FUNCTIONS):   if maxWeight eq . then maxWeight=weightList[i];
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if weightList[i]>maxWeight then maxWeight=weightList[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if dCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   beforeDistMean=beforeDistMean/dCount;
MPRINT(CI_FCMP_FUNCTIONS):   afterDistMean=afterDistMean/dCount;
MPRINT(CI_FCMP_FUNCTIONS):   distList[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to dCount;
MPRINT(CI_FCMP_FUNCTIONS):   distList[i]=distList[i]+(beforeDist[j]-beforeDistMean)**2+(afterDist[j]-afterDistMean)**2;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   distList[i]=sqrt (distList[i] / (dCount-1));
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array candiList2[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(candiList2, candiSize);
MPRINT(CI_FCMP_FUNCTIONS):   candiSize2=0;
MPRINT(CI_FCMP_FUNCTIONS):   if maxWeight ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to candiSize;
MPRINT(CI_FCMP_FUNCTIONS):   if weightList[i] eq maxWeight then do;
MPRINT(CI_FCMP_FUNCTIONS):   candiSize2=candiSize2+1;
MPRINT(CI_FCMP_FUNCTIONS):   candiList2[candiSize2]=candiList[i];
MPRINT(CI_FCMP_FUNCTIONS):   if minDist eq . then minDist=distList[i];
MPRINT(CI_FCMP_FUNCTIONS):   else if distList[i]<minDist then minDist=distList[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
10                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   candiSize2=candiSize;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to candiSize;
MPRINT(CI_FCMP_FUNCTIONS):   candiList2[i]=candiList[i];
MPRINT(CI_FCMP_FUNCTIONS):   if minDist eq . then minDist=distList[i];
MPRINT(CI_FCMP_FUNCTIONS):   else if distList[i]<minDist then minDist=distList[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if candiSize2 eq 1 then eventIdx=candiList2[1];
MPRINT(CI_FCMP_FUNCTIONS):   else if candiSize2 > 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if minDist ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   array candiList3[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(candiList3, candiSize2);
MPRINT(CI_FCMP_FUNCTIONS):   candiSize3=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to candiSize2;
MPRINT(CI_FCMP_FUNCTIONS):   if distList[i] eq minDist then do;
MPRINT(CI_FCMP_FUNCTIONS):   candiSize3=candiSize3+1;
MPRINT(CI_FCMP_FUNCTIONS):   candiList3[candiSize3]=candiList2[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   eventIdx=candiList3[1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   eventIdx=candiList2[1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else rc=4;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_get_event_date(eventFile $, eventSize, eventIdx, eventDate[*], eventCount, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs eventDate, eventCount, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   size= dim(eventDate);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to size;
MPRINT(CI_FCMP_FUNCTIONS):   eventDate[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   eventCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   array tmp[1,1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(tmp, eventSize, 2);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   tmp[t,1]=.;
MPRINT(CI_FCMP_FUNCTIONS):   tmp[t,2]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   temp_rc = read_array(eventFile, tmp, 'event_idx' , 'event_date');
11                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   if temp_rc=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to eventSize;
MPRINT(CI_FCMP_FUNCTIONS):   if tmp[t,1] eq eventIdx and tmp[t,2] ne . and eventCount<size then do;
MPRINT(CI_FCMP_FUNCTIONS):   eventCount = eventCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   eventDate[eventCount]=tmp[t,2];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_event_distance(periodStart[*], periodEnd[*], periodCount, timeID[*], demandSize, eventDate[*], eventCount, interval $, eventDefBufferLen, eventIdx, beforeDist[*], afterDist[*], rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs beforeDist, afterDist, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc= 3;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(beforeDist);
MPRINT(CI_FCMP_FUNCTIONS):   beforeDist[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(afterDist);
MPRINT(CI_FCMP_FUNCTIONS):   afterDist[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   if eventCount>0 and periodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(beforeDist) eq dim(afterDist) then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   do k=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   s=periodStart[k];
MPRINT(CI_FCMP_FUNCTIONS):   e=periodEnd[k];
MPRINT(CI_FCMP_FUNCTIONS):   bc = INTCK( interval, timeID[s], eventDate[j]);
MPRINT(CI_FCMP_FUNCTIONS):   ac = INTCK( interval, eventDate[j], timeID[e]);
MPRINT(CI_FCMP_FUNCTIONS):   if bc>=-eventDefBufferLen and ac>=-eventDefBufferLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   count=count+1;
MPRINT(CI_FCMP_FUNCTIONS):   beforeDist[count]=bc;
MPRINT(CI_FCMP_FUNCTIONS):   afterDist[count]=ac;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_event_compute_next_period_distance(eventDate[*], eventCount, interval $, date, beforeDist);
MPRINT(CI_FCMP_FUNCTIONS):   dist=.;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   bc = INTCK( interval, date, eventDate[i]);
MPRINT(CI_FCMP_FUNCTIONS):   if bc>beforeDist then do;
MPRINT(CI_FCMP_FUNCTIONS):   if dist eq . then dist=bc;
MPRINT(CI_FCMP_FUNCTIONS):   else if bc<dist then dist=bc;
MPRINT(CI_FCMP_FUNCTIONS):   end;
12                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if dist ne . then dist=dist-beforeDist;
MPRINT(CI_FCMP_FUNCTIONS):   return(dist);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_run_forecast(demand[*], timeID[*], interval $, seasonality, lead, sign $, criterion $, repositoryNm $, diagEstNm $, indataset $, outdataset $, forecast[*], fTimeID[*], rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs forecast, fTimeID, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc= 1;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(fTimeID);
MPRINT(CI_FCMP_FUNCTIONS):   fTimeID[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(forecast);
MPRINT(CI_FCMP_FUNCTIONS):   forecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(demand) eq dim(timeID) then do;
MPRINT(CI_FCMP_FUNCTIONS):   size=dim(demand);
MPRINT(CI_FCMP_FUNCTIONS):   rc=5;
MPRINT(CI_FCMP_FUNCTIONS):   array series[1,2] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(series, size, 2);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to size;
MPRINT(CI_FCMP_FUNCTIONS):   series[t,1]=timeID[t];
MPRINT(CI_FCMP_FUNCTIONS):   series[t,2]=demand[t];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   temp_rc = write_array(indataset, series, 'time_id', 'demand');
MPRINT(CI_FCMP_FUNCTIONS):   rc = 2;
MPRINT(CI_FCMP_FUNCTIONS):   if temp_rc=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc = 3;
MPRINT(CI_FCMP_FUNCTIONS):   temp_rc = run_macro('ci_run_hpf', indataset, outdataset, interval, criterion, repositoryNm, diagEstNm, seasonality, lead);
MPRINT(CI_FCMP_FUNCTIONS):   if temp_rc = 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=4;
MPRINT(CI_FCMP_FUNCTIONS):   array fcst[1,2] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(fcst, size+lead,2);
MPRINT(CI_FCMP_FUNCTIONS):   temp_rc = read_array(outdataset, fcst, 'time_id', 'predict');
MPRINT(CI_FCMP_FUNCTIONS):   if temp_rc = 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   outsize=dim(fTimeID);
MPRINT(CI_FCMP_FUNCTIONS):   if outsize>size+lead then outsize=size+lead;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   fTimeID[i]=fcst[i, 1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   outsize=dim(forecast);
MPRINT(CI_FCMP_FUNCTIONS):   if outsize>size+lead then outsize=size+lead;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   forecast[i]=fcst[i, 2];
MPRINT(CI_FCMP_FUNCTIONS):   if forecast[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   if sign eq "NONNEGATIVE" and forecast[i]<0 then forecast[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   if sign eq "NONPOSITIVE" and forecast[i]>0 then forecast[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
13                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_stretch_squeeze_series(origSeries[*], origPeriodStart[*], origPeriodEnd[*], origPeriodCount, newLen, newPeriodStart[*], newPeriodEnd[*], newSeries[*], newCount, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs newPeriodStart, newPeriodEnd, newSeries, newCount, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   newCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(newPeriodStart);
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodStart[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(newPeriodEnd);
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodEnd[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(newSeries);
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if origPeriodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   if newLen>=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   size=dim(origSeries);
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to origPeriodCount;
MPRINT(CI_FCMP_FUNCTIONS):   if origPeriodStart[i]>lastIndex+1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=lastIndex+1 to origPeriodStart[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   newCount = newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[newCount]=origSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex = origPeriodStart[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   origLen = origPeriodEnd[i]-origPeriodStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodStart[i]=newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   if origLen eq newLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=origPeriodStart[i] to origPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   newCount = newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[newCount]=origSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if origLen eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   k = origPeriodStart[i];
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   newCount = newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[newCount]=origSeries[k];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   newCount = newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   if newLen eq 1 then pos=(origPeriodStart[i] +origPeriodEnd[i])/2;
MPRINT(CI_FCMP_FUNCTIONS):   else pos=origPeriodStart[i] +(j-1)*(origLen-1)/(newLen-1);
14                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   k=floor(pos);
MPRINT(CI_FCMP_FUNCTIONS):   if pos eq k then newSeries[newCount]=origSeries[k];
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if origSeries[k] ne . and origSeries[k+1] ne . then newSeries[newCount]=(k+1-pos)*origSeries[k]+(pos-k)*origSeries[k+1];
MPRINT(CI_FCMP_FUNCTIONS):   else newSeries[newCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex = origPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodEnd[i]=newCount;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if lastIndex lt size then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=lastIndex+1 to size;
MPRINT(CI_FCMP_FUNCTIONS):   newCount = newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[newCount]=origSeries[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_recover_stretch_squeeze_series(newPeriodStart[*], newPeriodEnd[*], newSeries[*], newCount,newLen, origPeriodStart[*], origPeriodEnd[*], origPeriodCount, origSeries[*], origCount, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs origSeries, origCount, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   origCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(origSeries);
MPRINT(CI_FCMP_FUNCTIONS):   origSeries[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if origPeriodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   if newLen>=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to origPeriodCount;
MPRINT(CI_FCMP_FUNCTIONS):   if newPeriodStart[i]>lastIndex+1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=lastIndex+1 to newPeriodStart[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   origCount = origCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   origSeries[origCount]=newSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex = newPeriodStart[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   origLen = origPeriodEnd[i]-origPeriodStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if origLen eq newLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=newPeriodStart[i] to newPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   origCount = origCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   origSeries[origCount]=newSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if newLen eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   k = newPeriodStart[i];
15                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to origLen;
MPRINT(CI_FCMP_FUNCTIONS):   origCount = origCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   origSeries[origCount]=newSeries[k];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to origLen;
MPRINT(CI_FCMP_FUNCTIONS):   origCount = origCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   if origLen eq 1 then pos=(newPeriodStart[i] +newPeriodEnd[i])/2;
MPRINT(CI_FCMP_FUNCTIONS):   else pos=newPeriodStart[i] +(j-1)*(newLen-1)/(origLen-1);
MPRINT(CI_FCMP_FUNCTIONS):   k=floor(pos);
MPRINT(CI_FCMP_FUNCTIONS):   if pos eq k then origSeries[origCount]=newSeries[k];
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if newSeries[k] ne . and newSeries[k+1] ne . then origSeries[origCount]=(k+1-pos)*newSeries[k]+(pos-k)*newSeries[k+1];
MPRINT(CI_FCMP_FUNCTIONS):   else origSeries[origCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   lastIndex = newPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if lastIndex lt newCount then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=lastIndex+1 to newCount;
MPRINT(CI_FCMP_FUNCTIONS):   origCount = origCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   origSeries[origCount]=newSeries[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_run_forecast2(demand[*], seasonality, lead, sign $, forecast[*]);
MPRINT(CI_FCMP_FUNCTIONS):   outargs forecast;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(forecast);
MPRINT(CI_FCMP_FUNCTIONS):   forecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   size=dim(demand);
MPRINT(CI_FCMP_FUNCTIONS):   trailMissLen=ci_compute_trail_missing_length(demand, size);
MPRINT(CI_FCMP_FUNCTIONS):   if trailMissLen>0 then size=size-trailMissLen;
MPRINT(CI_FCMP_FUNCTIONS):   array avg[1,1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(avg, seasonality, 2);
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   avg[j,1]=.;
MPRINT(CI_FCMP_FUNCTIONS):   avg[j,2]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to size;
MPRINT(CI_FCMP_FUNCTIONS):   if demand[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   j= mod(i,seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if j eq 0 then j=seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   if avg[j,1] ne . then avg[j,1]=avg[j,1]+demand[i];
MPRINT(CI_FCMP_FUNCTIONS):   else avg[j,1]=demand[i];
16                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   avg[j,2]=avg[j,2]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   if avg[j,2] ne 0 then avg[j,1]=avg[j,1]/avg[j,2];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   outsize=dim(forecast);
MPRINT(CI_FCMP_FUNCTIONS):   if outsize>size+lead then outsize=size+lead;
MPRINT(CI_FCMP_FUNCTIONS):   cycCount=ceil(outsize/seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   array cycTot[1,2] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(cycTot, cycCount,2);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to cycCount;
MPRINT(CI_FCMP_FUNCTIONS):   cycTot[i,1]=0;
MPRINT(CI_FCMP_FUNCTIONS):   cycTot[i,2]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to size;
MPRINT(CI_FCMP_FUNCTIONS):   j= mod(i,seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if j eq 0 then j=seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   k=ceil(i/seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if demand[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   cycTot[k,1]=cycTot[k,1]+abs(demand[i]);
MPRINT(CI_FCMP_FUNCTIONS):   cycTot[k,2]=cycTot[k,2]+abs(avg[j,1]);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   j= mod(i,seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if j eq 0 then j=seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   k=ceil(i/seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if cycTot[k,1] ne 0 and cycTot[k,2] ne 0 then forecast[i]=avg[j,1]*cycTot[k,1]/cycTot[k,2];
MPRINT(CI_FCMP_FUNCTIONS):   else forecast[i]=avg[j,1];
MPRINT(CI_FCMP_FUNCTIONS):   if forecast[i] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   if sign eq "NONNEGATIVE" and forecast[i]<0 then forecast[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   if sign eq "NONPOSITIVE" and forecast[i]>0 then forecast[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_forecast_measure(demand[*], forecast[*], size, measure $, score, count);
MPRINT(CI_FCMP_FUNCTIONS):   outargs score, count;
MPRINT(CI_FCMP_FUNCTIONS):   score=.;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   msize = size;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(demand)<msize then msize=dim(demand);
MPRINT(CI_FCMP_FUNCTIONS):   if dim(forecast)<msize then msize=dim(forecast);
MPRINT(CI_FCMP_FUNCTIONS):   array avg[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(avg, msize);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   avg[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   if demand[i] ne . and forecast[i] ne . then do;
17                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   count=count+1;
MPRINT(CI_FCMP_FUNCTIONS):   if measure="MAPE" then do;
MPRINT(CI_FCMP_FUNCTIONS):   if demand[i] ne 0 then avg[count]=abs((demand[i]-forecast[i])/demand[i]);
MPRINT(CI_FCMP_FUNCTIONS):   else if forecast[i] ne 0 then avg[count]=abs((demand[i]-forecast[i])/forecast[i]);
MPRINT(CI_FCMP_FUNCTIONS):   else avg[count]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if measure="MAE" then avg[count]=abs(demand[i]-forecast[i]);
MPRINT(CI_FCMP_FUNCTIONS):   else if measure="MSE" then avg[count]=(demand[i]-forecast[i])**2;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if count>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   score=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   if avg[i] ne . then score=score+avg[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   score=score/count;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_event_series_seasons(timeID[*], eventDate[*], eventCount, interval $, beforeDist, afterDist, seasonCode[*], inSeasonLen, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs seasonCode, inSeasonLen, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc= 2;
MPRINT(CI_FCMP_FUNCTIONS):   inSeasonLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   seasonCode[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   if eventCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   count=0;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(timeID);
MPRINT(CI_FCMP_FUNCTIONS):   found=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to eventCount;
MPRINT(CI_FCMP_FUNCTIONS):   bc = INTCK( interval, timeID[t], eventDate[j]);
MPRINT(CI_FCMP_FUNCTIONS):   ac = INTCK( interval, eventDate[j], timeID[t]);
MPRINT(CI_FCMP_FUNCTIONS):   if bc<=beforeDist and ac<=afterDist then do;
MPRINT(CI_FCMP_FUNCTIONS):   found=1;
MPRINT(CI_FCMP_FUNCTIONS):   seasonCode[t]=beforeDist-bc+1;
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t]>inSeasonLen then inSeasonLen=seasonCode[t];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if found=0 then seasonCode[t]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_off_periods_by_code(seasonCode[*], firstPartialFlag, lastPartialFlag, offStart[*], offEnd[*], offCount);
MPRINT(CI_FCMP_FUNCTIONS):   outargs offStart, offEnd, offCount;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(offStart);
MPRINT(CI_FCMP_FUNCTIONS):   offStart[t]=.;
18                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(offEnd);
MPRINT(CI_FCMP_FUNCTIONS):   offEnd[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   msize=dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] eq . and t<=msize then msize=t-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if t eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if firstPartialFlag eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if seasonCode[t-1] ne 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if t eq msize then offEnd[offCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   else if seasonCode[t+1] ne 0 then offEnd[offCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[offCount] ne . and offEnd[offCount] eq msize and lastPartialFlag eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   offEnd[offCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=offCount-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_inseason_periods_by_code(seasonCode[*], firstPartialFlag, lastPartialFlag, periodStart[*], periodEnd[*], periodCount);
MPRINT(CI_FCMP_FUNCTIONS):   outargs periodStart, periodEnd, periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(periodStart);
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(periodEnd);
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   msize=dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] eq . and t<=msize then msize=t-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[1] >1 and firstPartialFlag=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=1;
19                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] eq 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if t<msize then do;
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] ne 0 and seasonCode[t+1] <=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if seasonCode[t] >1 then periodEnd[periodCount]=t;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount>0 and periodEnd[periodCount]=msize and lastPartialFlag eq 0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_order_stats(seasonCode, min, median, max);
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[msize]<max then do;
MPRINT(CI_FCMP_FUNCTIONS):   periodStart[periodCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   periodEnd[periodCount]=.;
MPRINT(CI_FCMP_FUNCTIONS):   periodCount=periodCount-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_find_off_periods_length(offStart[*], offEnd[*], offCount, offSeasonRule $, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   newLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array offRange[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offRange, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   do k=1 to offCount;
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[k]<=totObs then offRange[k]=offEnd[k]-offStart[k]+1;
MPRINT(CI_FCMP_FUNCTIONS):   else offRange[k]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_basic_freq(offRange, _OFF_RANGE_COUNT, _OFF_RANGE_MIN, _OFF_RANGE_MEDIAN, _OFF_RANGE_MAX, _OFF_RANGE_MEAN, _OFF_RANGE_MODE);
MPRINT(CI_FCMP_FUNCTIONS):   if _OFF_RANGE_COUNT>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if offSeasonRule eq "MIN" then newLen=_OFF_RANGE_MIN;
MPRINT(CI_FCMP_FUNCTIONS):   else if offSeasonRule eq "MAX" then newLen=_OFF_RANGE_MAX;
MPRINT(CI_FCMP_FUNCTIONS):   else if offSeasonRule eq "MEAN" then newLen=ceil(_OFF_RANGE_MEAN);
MPRINT(CI_FCMP_FUNCTIONS):   else if offSeasonRule eq "MODE" then newLen=_OFF_RANGE_MODE;
MPRINT(CI_FCMP_FUNCTIONS):   else if offSeasonRule eq "MED" then newLen=ceil(_OFF_RANGE_MEDIAN);
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[_OFF_RANGE_COUNT]>=totObs and _OFF_RANGE_COUNT>2 then newLen=offEnd[_OFF_RANGE_COUNT-1]-offStart[_OFF_RANGE_COUNT-1]+1;
MPRINT(CI_FCMP_FUNCTIONS):   else newLen=offEnd[_OFF_RANGE_COUNT]-offStart[_OFF_RANGE_COUNT]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   return(newLen);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_split_series_by_period(origSeries[*], totObs, PeriodStart[*], PeriodEnd[*], periodCount, _inSeries[*], _offSeries[*], inIndex, offIndex);
MPRINT(CI_FCMP_FUNCTIONS):   outargs _inSeries, _offSeries, inIndex, offIndex;
MPRINT(CI_FCMP_FUNCTIONS):   offIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):   inIndex=0;
20                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   if PeriodStart[1]>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to PeriodStart[1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   if j<=totObs then do;
MPRINT(CI_FCMP_FUNCTIONS):   inIndex=inIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _inSeries[inIndex]=origSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   do j=PeriodStart[i] to PeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   if j<=totObs then do;
MPRINT(CI_FCMP_FUNCTIONS):   offIndex=offIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _offSeries[offIndex]=origSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if i<periodCount then endIndex=PeriodStart[i+1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   else endIndex=totObs;
MPRINT(CI_FCMP_FUNCTIONS):   if PeriodEnd[i]<endIndex then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=PeriodEnd[i]+1 to endIndex;
MPRINT(CI_FCMP_FUNCTIONS):   if j<=totObs then do;
MPRINT(CI_FCMP_FUNCTIONS):   inIndex=inIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _inSeries[inIndex]=origSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_combine_two_series_by_period(inSeries[*], offSeries[*], totObs, PeriodStart[*], PeriodEnd[*], periodCount, _combSeries[*], inIndex, offIndex, combIndex);
MPRINT(CI_FCMP_FUNCTIONS):   outargs _combSeries, inIndex, offIndex, combIndex;
MPRINT(CI_FCMP_FUNCTIONS):   combIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):  inIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):   offIndex=0;
MPRINT(CI_FCMP_FUNCTIONS):   if PeriodStart[1]>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to PeriodStart[1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   combIndex=combIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   inIndex=inIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _combSeries[combIndex]=inSeries[inIndex];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   do j=PeriodStart[i] to PeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   combIndex=combIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   offIndex=offIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _combSeries[combIndex]=offSeries[offIndex];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if i<periodCount then endIndex=PeriodStart[i+1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   else endIndex=totObs;
MPRINT(CI_FCMP_FUNCTIONS):   if PeriodEnd[i]<endIndex then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=PeriodEnd[i]+1 to endIndex;
MPRINT(CI_FCMP_FUNCTIONS):   combIndex=combIndex+1;
21                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   inIndex=inIndex+1;
MPRINT(CI_FCMP_FUNCTIONS):   _combSeries[combIndex]=inSeries[inIndex];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_combine_series_season(demand[*], seasonCode[*], accumulate $, comb[*], combCount[*], size, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs comb, combCount, size, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc= 2;
MPRINT(CI_FCMP_FUNCTIONS):   size=0;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(comb);
MPRINT(CI_FCMP_FUNCTIONS):   comb[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(combCount);
MPRINT(CI_FCMP_FUNCTIONS):   combCount[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   msize=dim(demand);
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(demand);
MPRINT(CI_FCMP_FUNCTIONS):   if seasonCode[t] eq . and t<=msize then msize=t-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array tmp[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   array offStart[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   array offEnd[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(tmp,msize);
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offStart,msize);
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offEnd,msize);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_off_periods_by_code(seasonCode, 1, 1, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   if offCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array eva[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(eva,offCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to offCount;
MPRINT(CI_FCMP_FUNCTIONS):   s=offStart[i];
MPRINT(CI_FCMP_FUNCTIONS):   ec=offEnd[i]-offStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   array off[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(off,ec);
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   off[j]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   missFlag=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to ec;
MPRINT(CI_FCMP_FUNCTIONS):   off[j]=demand[s+j-1];
MPRINT(CI_FCMP_FUNCTIONS):   if off[j] eq . then missFlag=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   eva[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   value=.;
MPRINT(CI_FCMP_FUNCTIONS):   if missFlag ne 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if accumulate eq "TOTAL" then call ci_compute_sum(off, value, count);
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "AVG" then call ci_compute_mean(off, value, count);
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "MIN" then call ci_compute_order_stats(off, value, median, max);
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "MED" then call ci_compute_order_stats(off, min, value, max);
22                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "MAX" then call ci_compute_order_stats(off, min, median, value);
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "FIRST" then value=off[1];
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "LAST" then value=off[ec];
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate eq "MODE" then call ci_compute_basic_freq(off, count, min, median, max, mean, value);
MPRINT(CI_FCMP_FUNCTIONS):   else rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   if rc ne 1 then eva[i]=value;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if rc ne 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   if offStart[1]>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to offStart[1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   size=size+1;
MPRINT(CI_FCMP_FUNCTIONS):   comb[size]=demand[i];
MPRINT(CI_FCMP_FUNCTIONS):   combCount[size]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to offCount;
MPRINT(CI_FCMP_FUNCTIONS):   size=size+1;
MPRINT(CI_FCMP_FUNCTIONS):   comb[size]=eva[i];
MPRINT(CI_FCMP_FUNCTIONS):   combCount[size]=offEnd[i]-offStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if i<offCount then do;
MPRINT(CI_FCMP_FUNCTIONS):   do t=offEnd[i]+1 to offStart[i+1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   size=size+1;
MPRINT(CI_FCMP_FUNCTIONS):   comb[size]=demand[t];
MPRINT(CI_FCMP_FUNCTIONS):   combCount[size]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[offCount]<msize then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=offEnd[offCount]+1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   size=size+1;
MPRINT(CI_FCMP_FUNCTIONS):   comb[size]=demand[i];
MPRINT(CI_FCMP_FUNCTIONS):   combCount[size]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to msize;
MPRINT(CI_FCMP_FUNCTIONS):   comb[t]=demand[t];
MPRINT(CI_FCMP_FUNCTIONS):   combCount[t]=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   size=msize;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_compute_profile(demand[*], PeriodStart[*], PeriodEnd[*], periodCount, newLen, profile[*]);
MPRINT(CI_FCMP_FUNCTIONS):   outargs profile;
23                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(profile);
MPRINT(CI_FCMP_FUNCTIONS):   profile[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array newSeries[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newSeries, newLen);
MPRINT(CI_FCMP_FUNCTIONS):   array profileCount[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(profileCount, newLen);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   profileCount[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   origLen=PeriodEnd[i]-PeriodStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if origLen ne newLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[j]=.;
MPRINT(CI_FCMP_FUNCTIONS):   if newLen eq 1 then pos=(PeriodStart[i] +PeriodEnd[i])/2;
MPRINT(CI_FCMP_FUNCTIONS):   else pos=PeriodStart[i] +(j-1)*(origLen-1)/(newLen-1);
MPRINT(CI_FCMP_FUNCTIONS):   k=floor(pos);
MPRINT(CI_FCMP_FUNCTIONS):   if pos eq k then newSeries[j]=demand[k];
MPRINT(CI_FCMP_FUNCTIONS):   else newSeries[j]=(k+1-pos)*demand[k]+(pos-k)*demand[k+1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   k=PeriodStart[i]+j-1;
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[j]=demand[k];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   if newSeries[j] ne . then do;
MPRINT(CI_FCMP_FUNCTIONS):   profileCount[j]=profileCount[j]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if profile[j] ne . then profile[j]=profile[j]+newSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   else profile[j]=newSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   if profileCount[j]>0 then profile[j]=profile[j]/profileCount[j];
MPRINT(CI_FCMP_FUNCTIONS):   else profile[j]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_recover_combine_series(comb[*], combCount[*], combSize, accumulate $, profile[*], orig[*], origSize, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs orig, origSize, rc;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to dim(orig);
MPRINT(CI_FCMP_FUNCTIONS):   orig[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   origSize=0;
MPRINT(CI_FCMP_FUNCTIONS):   pLen=dim(profile);
24                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   if pLen>0 and combSize>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to combSize;
MPRINT(CI_FCMP_FUNCTIONS):   if combCount[i]=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   array newSeries[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newSeries, combCount[i]);
MPRINT(CI_FCMP_FUNCTIONS):   total=0;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[j]=.;
MPRINT(CI_FCMP_FUNCTIONS):   pos=1 +(j-1)*(pLen-1)/(combCount[i]-1);
MPRINT(CI_FCMP_FUNCTIONS):   k=floor(pos);
MPRINT(CI_FCMP_FUNCTIONS):   if pos eq k then newSeries[j]=profile[k];
MPRINT(CI_FCMP_FUNCTIONS):   else newSeries[j]=(k+1-pos)*profile[k]+(pos-k)*profile[k+1];
MPRINT(CI_FCMP_FUNCTIONS):   total=total+newSeries[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if total=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   newSeries[j]=1/combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   total=combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_basic_freq(newSeries, count, min, median, max, mean, mode);
MPRINT(CI_FCMP_FUNCTIONS):   if accumulate = "TOTAL" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]*newSeries[j]/total;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "AVG" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-mean);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "MAX" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-max);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "MED" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-median);
MPRINT(CI_FCMP_FUNCTIONS):   end;
25                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "MIN" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-min);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "FIRST" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-newSeries[1]);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "LAST" then do;
MPRINT(CI_FCMP_FUNCTIONS):   k=combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-newSeries[k]);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if accumulate = "MODE" then do;
MPRINT(CI_FCMP_FUNCTIONS):   do j=1 to combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   origSize=origSize+1;
MPRINT(CI_FCMP_FUNCTIONS):   orig[origSize]=comb[i]+(newSeries[j]-mode);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if rc ne 2 then rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_find_season_series_seasons(periodStart[*], periodEnd[*], periodCount, totObs, inSeasonLen, ssIndex, seasonCode[*], rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs seasonCode, rc;
MPRINT(CI_FCMP_FUNCTIONS):   do t=1 to dim(seasonCode);
MPRINT(CI_FCMP_FUNCTIONS):   seasonCode[t]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   rc= 4;
MPRINT(CI_FCMP_FUNCTIONS):   array periodPos[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(periodPos, periodCount);
MPRINT(CI_FCMP_FUNCTIONS):   array newPeriod[1,2] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newPeriod, periodCount,2);
MPRINT(CI_FCMP_FUNCTIONS):   accM=1;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   options= ci_season_compute_option_count(periodStart, periodEnd, periodCount, totObs, inSeasonLen, i);
MPRINT(CI_FCMP_FUNCTIONS):   periodPos[i]=mod(ceil(ssIndex/accM), options);
26                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   if periodPos[i]=0 then periodPos[i]=options;
MPRINT(CI_FCMP_FUNCTIONS):   accM=accM*options;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if ssIndex<=0 or ssIndex>accM then rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   rc=4;
MPRINT(CI_FCMP_FUNCTIONS):   invalid=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,1]=.;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,2]=.;
MPRINT(CI_FCMP_FUNCTIONS):   if periodEnd[i]<periodStart[i] then invalid=1;
MPRINT(CI_FCMP_FUNCTIONS):   if periodEnd[i]-periodStart[i]+1>=inSeasonLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,1]=periodStart[i]+periodPos[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,2]=newPeriod[i,1]+inSeasonLen-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if i>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,1]=periodStart[i]-periodPos[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,2]=newPeriod[i,1]+inSeasonLen-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,2]=periodEnd[i]+periodPos[i]-1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriod[i,1]=newPeriod[i,2]-inSeasonLen+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if i>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if newPeriod[i,1]<=newPeriod[i-1,2]+1 then invalid=1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if invalid = 1 then rc=3;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to totObs;
MPRINT(CI_FCMP_FUNCTIONS):   seasonCode[i]=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   do j=newPeriod[i,1] to newPeriod[i,2];
MPRINT(CI_FCMP_FUNCTIONS):   if j>0 and j<=totObs then seasonCode[j]=j-newPeriod[i,1]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_find_season_start_index(periodStart[*], periodCount, seasonIndex[*], inSeasonRule $);
MPRINT(CI_FCMP_FUNCTIONS):   start=.;
MPRINT(CI_FCMP_FUNCTIONS):   if periodCount>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   off=0;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_order_stats(seasonIndex, _INDEX_MIN, _INDEX_MED, _INDEX_MAX);
MPRINT(CI_FCMP_FUNCTIONS):   array periodSIndex[1] / nosymbols;
27                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(periodSIndex, periodCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   j=periodStart[i];
MPRINT(CI_FCMP_FUNCTIONS):   periodSIndex[i]=seasonIndex[j];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_basic_freq(periodSIndex, _START_COUNT, _START_MIN, _START_MEDIAN, _START_MAX, _START_MEAN, _START_MODE);
MPRINT(CI_FCMP_FUNCTIONS):   if _START_MAX-_START_MIN>_START_MIN+_INDEX_MAX-_START_MAX then do;
MPRINT(CI_FCMP_FUNCTIONS):   off=1;
MPRINT(CI_FCMP_FUNCTIONS):   array newPeriodStart[1] / nosymbols;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newPeriodStart, periodCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to periodCount;
MPRINT(CI_FCMP_FUNCTIONS):   if periodSIndex[i]-_START_MIN>=_START_MAX-periodSIndex[i] then do;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodStart[i]=periodSIndex[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else newPeriodStart[i]=periodSIndex[i]+_INDEX_MAX;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_basic_freq(newPeriodStart, _START_COUNT, _START_MIN, _START_MEDIAN, _START_MAX, _START_MEAN, _START_MODE);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if inSeasonRule eq "MIN" then start=_START_MIN;
MPRINT(CI_FCMP_FUNCTIONS):   else if inSeasonRule eq "MAX" then start=_START_MAX;
MPRINT(CI_FCMP_FUNCTIONS):   else if inSeasonRule eq "MEAN" then start=floor(_START_MEAN);
MPRINT(CI_FCMP_FUNCTIONS):   else if inSeasonRule eq "MODE" then start=_START_MODE;
MPRINT(CI_FCMP_FUNCTIONS):   else if inSeasonRule eq "MED" then start=floor(_START_MEDIAN);
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   start=periodSIndex[periodCount];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if start>_INDEX_MAX then start=start-_INDEX_MAX;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   return(start);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_season_compute_next_period_distance(interval $, currentDate, currentIndex, startIndex, seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   dist=.;
MPRINT(CI_FCMP_FUNCTIONS):   if startIndex> currentIndex then temp_dist=startIndex-currentIndex;
MPRINT(CI_FCMP_FUNCTIONS):   else temp_dist=startIndex-currentIndex+seasonality;
MPRINT(CI_FCMP_FUNCTIONS):   if interval ne "" and INTSEAS(interval)=seasonality then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=-2 to 2;
MPRINT(CI_FCMP_FUNCTIONS):   nextDate=INTNX(interval,currentDate,temp_dist+i);
MPRINT(CI_FCMP_FUNCTIONS):   if INTINDEX(interval, nextDate, seasonality) eq startIndex then dist=INTCK(interval, currentDate, nextDate);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else dist=temp_dist;
MPRINT(CI_FCMP_FUNCTIONS):   return(dist);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_compute_trail_missing_length(series[*], totObs);
MPRINT(CI_FCMP_FUNCTIONS):   len=0;
MPRINT(CI_FCMP_FUNCTIONS):   if series[totObs] eq . then do;
MPRINT(CI_FCMP_FUNCTIONS):   flag=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to totObs;
MPRINT(CI_FCMP_FUNCTIONS):   j=totObs-i+1;
MPRINT(CI_FCMP_FUNCTIONS):   if series[j] ne . and flag eq 0 then do;
28                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   flag =1;
MPRINT(CI_FCMP_FUNCTIONS):   len=i-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   return(len);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_generate_forecast_one(demand[*], season_code[*], totObs, leadLen, trailLen, expectTrailLen, inLen, offSeasonRule $, idForecastMethod $, idForecastAccum $, idForecastMode $, sign $, forecastCriterion $, 
repositoryNm $, diagEstNm $, indataset $, outdataset $, _outForecast[*], outsize, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs _outForecast, outsize, rc;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   outsize=dim(_outForecast);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   _outForecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array offStart[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offStart, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   array offEnd[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offEnd, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   if expectTrailLen>0 and expectTrailLen ne trailLen then do;
MPRINT(CI_FCMP_FUNCTIONS):   removeTrail=1;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_off_periods_by_code(season_code, 0, 0, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   trimObs=totObs-trailLen;
MPRINT(CI_FCMP_FUNCTIONS):   newTotObs=totObs+expectTrailLen-trailLen;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   removeTrail=0;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_off_periods_by_code(season_code, 0, 1, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   trimObs=totObs;
MPRINT(CI_FCMP_FUNCTIONS):   newTotObs=totObs;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array trimDemand[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(trimDemand, trimObs);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to trimObs;
MPRINT(CI_FCMP_FUNCTIONS):   if i<=leadLen then trimDemand[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   else trimDemand[i]=demand[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   trailMissLen=ci_compute_trail_missing_length(demand, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   newLen=ci_find_off_periods_length(offStart, offEnd, offCount, offSeasonRule, totObs-trailMissLen);
MPRINT(CI_FCMP_FUNCTIONS):   array _combOrigFSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_combOrigFSeries, newTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   if idForecastMethod = "ACCUMULATE" then do;
MPRINT(CI_FCMP_FUNCTIONS):   array _combSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_combSeries, trimObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _combCount[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_combCount, trimObs);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_combine_series_season(trimDemand, season_code, idForecastAccum, _combSeries, _combCount, combTotCount, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   if removeTrail=1 then lead=1;
MPRINT(CI_FCMP_FUNCTIONS):   else lead=0;
MPRINT(CI_FCMP_FUNCTIONS):   trailMissLen=ci_compute_trail_missing_length(_combSeries, combTotCount);
29                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   newCount=combTotCount-trailMissLen;
MPRINT(CI_FCMP_FUNCTIONS):   array _toForecast[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_toForecast, newCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to newCount;
MPRINT(CI_FCMP_FUNCTIONS):   _toForecast[i]=_combSeries[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array _fcst[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_fcst, combTotCount);
MPRINT(CI_FCMP_FUNCTIONS):   array _fcstCount[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_fcstCount, combTotCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to combTotCount;
MPRINT(CI_FCMP_FUNCTIONS):   _fcstCount[i]=_combCount[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if removeTrail=1 then _fcstCount[combTotCount] = expectTrailLen;
MPRINT(CI_FCMP_FUNCTIONS):   lead=lead+trailMissLen;
MPRINT(CI_FCMP_FUNCTIONS):   if idForecastMode = "ALL" then do;
MPRINT(CI_FCMP_FUNCTIONS):   array _toTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_toTimeID, newCount);
MPRINT(CI_FCMP_FUNCTIONS):   array _fTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_fTimeID, newCount+lead);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to newCount;
MPRINT(CI_FCMP_FUNCTIONS):   _toTimeID[i]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast(_toForecast, _toTimeID, "DAY", inLen+1, lead, sign, forecastCriterion, repositoryNm, diagEstNm, indataset, outdataset,_fcst,_fTimeID, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast2(_toForecast, inLen+1, lead, sign, _fcst);
MPRINT(CI_FCMP_FUNCTIONS):   if leadLen>0 then _fcst[1]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array offProfile[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offProfile, newLen);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_compute_profile(trimDemand, offStart, offEnd, offCount, newLen, offProfile);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_recover_combine_series(_fcst, _fcstCount, combTotCount, idForecastAccum, offProfile, _combOrigFSeries, origSize, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   if origSize<outsize then outsize=origSize;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   if i<=leadLen then _outForecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   else _outForecast[i]=_combOrigFSeries[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   array newSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newSeries, totObs+(offCount+1)*newLen);
MPRINT(CI_FCMP_FUNCTIONS):   array newPeriodStart[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newPeriodStart, offCount+2);
MPRINT(CI_FCMP_FUNCTIONS):   array newPeriodEnd[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(newPeriodEnd, offCount+2);
MPRINT(CI_FCMP_FUNCTIONS):   if leadLen>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if removeTrail=1 then call ci_find_off_periods_by_code(season_code, 1, 0, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   else call ci_find_off_periods_by_code(season_code, 1, 1, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   end;
30                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   call ci_stretch_squeeze_series(trimDemand, offStart, offEnd, offCount, newLen, newPeriodStart, newPeriodEnd, newSeries, newCount, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   offTotObs=newLen*offCount;
MPRINT(CI_FCMP_FUNCTIONS):   if removeTrail = 1 then offLead=newLen;
MPRINT(CI_FCMP_FUNCTIONS):   else offLead=0;
MPRINT(CI_FCMP_FUNCTIONS):   combTotObs=newCount+offLead;
MPRINT(CI_FCMP_FUNCTIONS):   inLead=0;
MPRINT(CI_FCMP_FUNCTIONS):   inTotObs=newCount-offTotObs;
MPRINT(CI_FCMP_FUNCTIONS):   trailMissLen=ci_compute_trail_missing_length(newSeries, newCount);
MPRINT(CI_FCMP_FUNCTIONS):   if trailMissLen>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offMissCount=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to offCount;
MPRINT(CI_FCMP_FUNCTIONS):   do j=newPeriodStart[i] to newPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   if j>newCount-trailMissLen then offMissCount=offMissCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   inLead=trailMissLen-offMissCount;
MPRINT(CI_FCMP_FUNCTIONS):   offLead=offLead+offMissCount;
MPRINT(CI_FCMP_FUNCTIONS):   inTotObs=inTotObs-inLead;
MPRINT(CI_FCMP_FUNCTIONS):   offTotObs=offTotObs-offMissCount;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array _inSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_inSeries, inTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _inFcst[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_inFcst, inTotObs+inLead);
MPRINT(CI_FCMP_FUNCTIONS):   array _offSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_offSeries, offTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _offFcst[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_offFcst, offTotObs+offLead);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_split_series_by_period(newSeries, newCount-trailMissLen, newPeriodStart, newPeriodEnd, offCount, _inSeries, _offSeries, inIndex, offIndex);
MPRINT(CI_FCMP_FUNCTIONS):   if idForecastMode = "ALL" then do;
MPRINT(CI_FCMP_FUNCTIONS):   array _inTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_inTimeID, inTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _inFTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_inFTimeID, inTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _offTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_offTimeID, offTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   array _offFTimeID[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_offFTimeID, offTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to inTotObs;
MPRINT(CI_FCMP_FUNCTIONS):   _inTimeID[i]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to offTotObs;
MPRINT(CI_FCMP_FUNCTIONS):   _offTimeID[i]=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast(_inSeries, _inTimeID, "DAY", inLen, inLead, sign, forecastCriterion, repositoryNm, diagEstNm, indataset, outdataset,_inFcst,_inFTimeID, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast(_offSeries, _offTimeID, "DAY", newLen, offLead, sign, forecastCriterion, repositoryNm, diagEstNm, indataset, outdataset,_offFcst,_offFTimeID, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast2(_inSeries, inLen, inLead, sign, _inFcst);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_run_forecast2(_offSeries, newLen, offLead, sign, _offFcst);
31                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   if leadLen>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to newLen;
MPRINT(CI_FCMP_FUNCTIONS):   _offFcst[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if removeTrail = 1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   offCount=offCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodStart[offCount]=newCount+1;
MPRINT(CI_FCMP_FUNCTIONS):   newPeriodEnd[offCount]=combTotObs;
MPRINT(CI_FCMP_FUNCTIONS):   offStart[offCount]=totObs-trailLen+1;
MPRINT(CI_FCMP_FUNCTIONS):   offEnd[offCount]=offStart[offCount]+expectTrailLen-1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   array _combSeries[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(_combSeries, combTotObs);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_combine_two_series_by_period(_inFcst, _offFcst, combTotObs, newPeriodStart, newPeriodEnd, offCount, _combSeries, inIndex, offIndex, combIndex);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_recover_stretch_squeeze_series(newPeriodStart, newPeriodEnd, _combSeries, combTotObs,newLen, offStart, offEnd, offCount, _combOrigFSeries, origSize, tmp_rc);
MPRINT(CI_FCMP_FUNCTIONS):   if origSize<outsize then outsize=origSize;
MPRINT(CI_FCMP_FUNCTIONS):   lastMissId=0;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to outsize;
MPRINT(CI_FCMP_FUNCTIONS):   if i<=leadLen then _outForecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   else _outForecast[i]=_combOrigFSeries[i];
MPRINT(CI_FCMP_FUNCTIONS):   if _outForecast[i] eq . and i>lastMissId then lastMissId=i;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if lastMissId>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to lastMissId;
MPRINT(CI_FCMP_FUNCTIONS):   _outForecast[i]=.;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_season_find_trim_info(timeID[*], season_code[*], season_index[*], totObs, interval $, seasonality, seasonStart, leadLen, trailLen, expectTrailLen, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs leadLen, trailLen, expectTrailLen, rc;
MPRINT(CI_FCMP_FUNCTIONS):   leadLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   trailLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   expectTrailLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   if dim(timeID)<totObs or dim(season_code)<totObs or dim(season_index)<totObs then rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if season_code[1]=0 or season_code[totObs]=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array offStart[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offStart, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   array offEnd[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offEnd, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_off_periods_by_code(season_code, 1, 1, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   if offStart[1]=1 then leadLen=offEnd[1];
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[offCount]=totObs then trailLen=offEnd[offCount]-offStart[offCount]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if trailLen>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   expectTrailLen=ci_season_compute_next_period_distance(interval, timeID[totObs-trailLen+1], season_index[totObs-trailLen+1], seasonStart, seasonality);
MPRINT(CI_FCMP_FUNCTIONS):   if expectTrailLen eq . then expectTrailLen=trailLen;
32                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   subroutine ci_event_find_trim_info(timeID[*], season_code[*], eventDate[*], totObs, eventCount, interval $, beforeDist, leadLen, trailLen, expectTrailLen, rc);
MPRINT(CI_FCMP_FUNCTIONS):   outargs leadLen, trailLen, expectTrailLen, rc;
MPRINT(CI_FCMP_FUNCTIONS):   leadLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   trailLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   expectTrailLen=0;
MPRINT(CI_FCMP_FUNCTIONS):   rc=0;
MPRINT(CI_FCMP_FUNCTIONS):   if eventCount<1 then rc=2;
MPRINT(CI_FCMP_FUNCTIONS):   else if dim(timeID)<totObs or dim(season_code)<totObs then rc=1;
MPRINT(CI_FCMP_FUNCTIONS):   else do;
MPRINT(CI_FCMP_FUNCTIONS):   if season_code[1]=0 or season_code[totObs]=0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   array offStart[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offStart, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   array offEnd[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(offEnd, totObs);
MPRINT(CI_FCMP_FUNCTIONS):   call ci_find_off_periods_by_code(season_code, 1, 1, offStart, offEnd, offCount);
MPRINT(CI_FCMP_FUNCTIONS):   if offStart[1]=1 then leadLen=offEnd[1];
MPRINT(CI_FCMP_FUNCTIONS):   if offEnd[offCount]=totObs then trailLen=offEnd[offCount]-offStart[offCount]+1;
MPRINT(CI_FCMP_FUNCTIONS):   if trailLen>0 then do;
MPRINT(CI_FCMP_FUNCTIONS):   expectTrailLen=ci_event_compute_next_period_distance(eventDate, eventCount, interval, timeID[totObs-trailLen+1], beforeDist);
MPRINT(CI_FCMP_FUNCTIONS):   if expectTrailLen eq . then expectTrailLen=trailLen;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   function ci_season_compute_option_count(allPeriodStart[*], allPeriodEnd[*], allPeriodCount, totObs, sl, t);
MPRINT(CI_FCMP_FUNCTIONS):   options=1;
MPRINT(CI_FCMP_FUNCTIONS):   array allPeriodRange[1]/NOSYMBOLS;
MPRINT(CI_FCMP_FUNCTIONS):   call dynamic_array(allPeriodRange, allPeriodCount);
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to allPeriodCount;
MPRINT(CI_FCMP_FUNCTIONS):   allPeriodRange[i]=allPeriodEnd[i]-allPeriodStart[i]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   options = abs(allPeriodRange[t]-sl)+1;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodRange[t]<sl then do;
MPRINT(CI_FCMP_FUNCTIONS):   if t>1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodRange[t-1]<=sl then minEnd=allPeriodEnd[t-1];
MPRINT(CI_FCMP_FUNCTIONS):   else minEnd=allPeriodStart[t-1]+sl-1;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodStart[t]-minEnd-1<options then options=allPeriodStart[t]-minEnd-1;
MPRINT(CI_FCMP_FUNCTIONS):   if t eq allPeriodCount and t>2 and allPeriodEnd[t] eq totObs then do;
MPRINT(CI_FCMP_FUNCTIONS):   minOff=allPeriodEnd[t];
MPRINT(CI_FCMP_FUNCTIONS):   do i=1 to t-1;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodStart[i+1]-allPeriodEnd[i]<minOff then minOff=allPeriodStart[i+1]-allPeriodEnd[i];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if options>allPeriodStart[t]-(allPeriodEnd[t-1]+minOff)+1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   options=allPeriodStart[t]-(allPeriodEnd[t-1]+minOff)+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
33                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   else if allPeriodCount>2 and allPeriodStart[1]=1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodRange[2]>sl then maxStart=allPeriodEnd[2]-sl+1;
MPRINT(CI_FCMP_FUNCTIONS):   else maxStart=allPeriodStart[2];
MPRINT(CI_FCMP_FUNCTIONS):   if maxStart-allPeriodEnd[1]-1<options then options=maxStart-allPeriodEnd[1]-1;
MPRINT(CI_FCMP_FUNCTIONS):   minOff=allPeriodEnd[allPeriodCount];
MPRINT(CI_FCMP_FUNCTIONS):  ;
MPRINT(CI_FCMP_FUNCTIONS):   do i=2 to allPeriodCount;
MPRINT(CI_FCMP_FUNCTIONS):   if allPeriodStart[i]-allPeriodEnd[i-1]<minOff then minOff=allPeriodStart[i]-allPeriodEnd[i-1];
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if options>allPeriodStart[2]-minOff-allPeriodEnd[1]+1 then do;
MPRINT(CI_FCMP_FUNCTIONS):   options=allPeriodStart[2]-minOff-allPeriodEnd[1]+1;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   end;
MPRINT(CI_FCMP_FUNCTIONS):   if options<1 then options=1;
MPRINT(CI_FCMP_FUNCTIONS):   return(options);
MPRINT(CI_FCMP_FUNCTIONS):   endsub;
MPRINT(CI_FCMP_FUNCTIONS):   run;
NOTE: Function ci_event_find_trim_info saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_season_find_trim_info saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_generate_forecast_one saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_season_compute_next_period_distance saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_season_start_index saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_season_compute_option_count saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_season_series_seasons saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_recover_combine_series saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_profile saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_combine_series_season saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_combine_two_series_by_period saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_split_series_by_period saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_off_periods_length saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_inseason_periods_by_code saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_off_periods_by_code saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_event_series_seasons saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_forecast_measure saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_trail_missing_length saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_run_forecast2 saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_recover_stretch_squeeze_series saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_stretch_squeeze_series saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_run_forecast saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_event_compute_next_period_distance saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_event_distance saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_get_event_date saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_active_event saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_offseason_period_range saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_find_active_period_range saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_basic_freq saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_order_stats saved to _ciTmp.ciFuncs.funcs.
NOTE: Function ci_compute_mean saved to _ciTmp.ciFuncs.funcs.
34                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

NOTE: Function ci_compute_sum saved to _ciTmp.ciFuncs.funcs.
NOTE: PROCEDURE FCMP used (Total process time):
      real time           11.73 seconds
      cpu time            1.46 seconds
      

MPRINT(CI_FCMP_FUNCTIONS):   quit;
...Starting Custom Interval Identification Component...
********INPUT ARGUMENT VALUE INTO CUSTOM_INTERVAL_IDENTIFICATION:********

localArgs=    table: 0000000009DB9100=
{
  ["ltsMinDemandCycLen"]=39
  ["fcstEnd"]="'18FEB2012'd"
  ["idForecastMethod"]="ACCUMULATE"
  ["forecastFlag"]=1
  ["processLib"]="_ciTmp"
  ["end"]="'18FEB2012'd"
  ["eventDefBufferLen"]=0
  ["align"]="E"
  ["byVars"]=""
  ["outArray"]="_ciTmp.ciIDOutArray"
  ["debug"]=1
  ["offSeasonRule"]="MEAN"
  ["lead"]=0
  ["outScalar"]="_ciTmp.ciIDOutScalar"
  ["eventIdentifyFlag"]=1
  ["idForecastMode"]="AVG"
  ["segMaxError"]=""
  ["idForecastCriterion"]="MSE"
  ["setmissing"]=0
  ["eventDefList"]="VALENTINES EASTER HALLOWEEN CHRISTMAS"
  ["seasonIndexData"]=""
  ["start"]="'07JUN2008'd"
  ["inData"]="_ciTmp.inDataFiltered"
  ["idInterval"]="WEEK"
  ["eventPeriodLenThreshold"]=9
  ["demandVar"]="TOTAL_ADJ_SALES_AMT"
  ["cmpLib"]="_ciTmp.ciFuncs"
63                                      The SAS System              14:29 Monday, April 9, 2018

  ["idForecastSign"]="MIXED"
  ["inSeasonRule"]="MEAN"
  ["segMaxPctError"]=""
  ["accumulate"]="TOTAL"
  ["idVar"]="EOW_DATE"
  ["seasonIndexVar"]=""
  ["zeroDemandThreshold"]=0
  ["gapPeriodThreshold"]=13
  ["zeroDemandThresholdPct"]=0.005
  ["idForecastAccumulate"]="TOTAL"
  ["seasonality"]=52
}
      proc catalog catalog=_ciTmp.TmpModRepCopy;
        copy in=sashelp.hpfdflt out=_ciTmp.TmpModRepCopy;
      quit;
     
NOTE: Copying entry ADDWINTERS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry AIRLINE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA000011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA011100NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA012011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA022011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA200100.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA210011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry ARIMA212011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry BEST.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry BESTN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry BESTS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry DAMPTREND.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry DOUBLE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry EXMNOLIMITS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry EXMNOSTD.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry EXMODEL.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry EXMSELECT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LINEAR.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LINEARSEASONALDUMMIES.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LINEARTREND.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LINEARTRENDAR.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGADDWINTERS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGAIRLINE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA000011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA011100NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA012011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA022011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA200100.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA210011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGARIMA212011NOINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGDAMPTREND.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGDOUBLE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGLINEAR.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGLINEARSEASONALDUMMIES.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGLINEARTREND.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGLINEARTRENDAR.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGMEAN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGRWWD.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGSEASONAL.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGSEASONALDUMMIES.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGSIMPLE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LOGWINTERS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
35                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

NOTE: Copying entry LSMADWN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMDAMP.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMDOUB.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMLIN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMSEAS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMSIMP.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry LSMWINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry MEAN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry RWWD.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SEASONAL.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SEASONALDUMMIES.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SIMPLE.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMADWN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMDAMP.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMDOUB.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMLIN.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMSEAS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMSIMP.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry SMWINT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry TSFSSELECT.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: Copying entry WINTERS.XML from catalog SASHELP.HPFDFLT to catalog _CITMP.TMPMODREPCOPY.
NOTE: PROCEDURE CATALOG used (Total process time):
      real time           0.96 seconds
      cpu time            0.14 seconds
      

    
    
      %macro ci_run_hpf;
      
        %let indataset  = %sysfunc(dequote(&indataset));
        %let outdataset = %sysfunc(dequote(&outdataset));
        %let interval = %sysfunc(dequote(&interval));
        %let criterion = %sysfunc(dequote(&criterion));
        %let repositoryNm = %sysfunc(dequote(&repositoryNm));
        %let diagEstNm = %sysfunc(dequote(&diagEstNm));
        
        proc hpfdiagnose data = &indataset
              outest = &diagEstNm RETAINCHOOSE=YES 
              seasonality = &seasonality
              errorcontrol = (severity = HIGH stage = (PROCEDURELEVEL)) EXCEPTIONS = CATCH  
              modelrepository =&repositoryNm
              back = 0 criterion = &criterion;
            forecast demand /acc = total setmissing = MISSING trimmiss = NONE zeromiss = NONE;
            id time_id interval=&interval acc = total notsorted 
               setmissing = MISSING 
               trimmiss = NONE zeromiss = NONE;
        run;
            
      
        proc hpfengine data = &indataset
            inest = &diagEstNm modelrepository =&repositoryNm
            outfor = &outdataset out=_NULL_ 
            outest = &diagEstNm 
            
            task = select(  criterion = &criterion override)
            back = 0  lead=&lead              
            seasonality = &seasonality errorcontrol=(severity=HIGH, stage=(PROCEDURELEVEL))
            EXCEPTIONS=CATCH   
            ;
64                                      The SAS System              14:29 Monday, April 9, 2018

            forecast demand /acc = total setmissing = MISSING trimmiss = NONE zeromiss = NONE;
            id time_id interval=&interval acc = total notsorted 
               setmissing = MISSING 
               trimmiss = NONE zeromiss = NONE;
        run;

      %mend;    
    
        data _ciTmp.ciIdEventFile;
          format event_idx 8. event_name $20. year 8. event_date date9. weight 8.;
          year1=YEAR('07JUN2008'd)-1;
          year2=YEAR('18FEB2012'd)+1;
          do year=year1 to year2;event_idx=1; event_name='VALENTINES'; 
event_date=holiday('VALENTINES', year); weight=1;output; end;do year=year1 to 
year2;event_idx=2; event_name='EASTER'; event_date=holiday('EASTER', year); weight=1;output; 
end;do year=year1 to year2;event_idx=3; event_name='HALLOWEEN'; 
event_date=holiday('HALLOWEEN', year); weight=1;output; end;do year=year1 to 
year2;event_idx=4; event_name='CHRISTMAS'; event_date=holiday('CHRISTMAS', year); 
weight=1;output; end;
          keep event_idx event_name year event_date weight;
          count=(year2-year1+1)*4;
          call symputx('ciIdEventFileObs', count);
        run;
      
NOTE: The data set _CITMP.CIIDEVENTFILE has 28 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.31 seconds
      cpu time            0.00 seconds
      

    %dcc_class_fcmp_fnc(cmp_lib=_ciTmp.timefnc);
    options cmplib = (_ciTmp.ciFuncs _ciTmp.timefnc);
    proc sort data=_ciTmp.inDataFiltered; by  EOW_DATE; run;
    
  
      proc timedata data=_ciTmp.inDataFiltered out=_ciTmp.ciIdOutAgg  
outscalar=_ciTmp.ciIDOutScalar outarray=_ciTmp.ciIDOutArray seasonality=52 lead=0;
        ;
        id EOW_DATE interval=WEEK accumulate=TOTAL setmissing=0 align=E start='07JUN2008'd 
end='18FEB2012'd;
        var TOTAL_ADJ_SALES_AMT;
        outscalars STS_TYPE SEASON_START SEASON_LENGTH EVENT_INDEX BEFORE_EVENT AFTER_EVENT 
_LOCAL_ZERO_THRESHOLD _DEMAND_CYC_LEN_MAX _DEMAND_CYC_LEN_MEAN _CURRENT_CYC_INDEX 
_TRAILING_ZERO_LEN _SEASON_LENGTH_MIN _SEASON_LENGTH_MAX _BEFORE_DIST_MIN _BEFORE_DIST_MAX 
_AFTER_DIST_MIN _AFTER_DIST_MAX bestSS _BEST_SCORE _EVA_COUNT;
        outarrays _season_code _season_index _ci_fcst _seg_index _seg_value _active_demand 
_demand_cycle_len _period_start _period_end _event_date _before_dist _after_dist _season_flag 
_out_fcst _eva_score;
        register TSA;
      
      
      /************************************************
        initialize scalar values
      ************************************************/
      _TOT_NOBS = dim(TOTAL_ADJ_SALES_AMT)-0;
      _LEADING_ZERO_LEN=.;_TRAILING_ZERO_LEN=.;_TRIM_NOBS=.;
65                                      The SAS System              14:29 Monday, April 9, 2018

      _ABS_DEMAND_MAX=.;
      _DEMAND_CYC_LEN_COUNT=.; _CURRENT_CYC_INDEX=.; _CURRENT_CYC_INDEX=.;
      _DEMAND_CYC_LEN_MEAN=.; _DEMAND_CYC_LEN_MIN=.; _DEMAND_CYC_LEN_MAX=.;
      _SEASON_LENGTH_MIN=.; _SEASON_LENGTH_MAX=.; 
      _BEFORE_DIST_MIN=.; _BEFORE_DIST_MAX=.; _AFTER_DIST_MIN=.; _AFTER_DIST_MAX=.;
      _EVA_COUNT=0; bestSS=.;
      
      STS_TYPE = -1;
      SEASON_START=.; SEASON_LENGTH=.; EVENT_INDEX=.; BEFORE_EVENT=.; AFTER_EVENT=.; 
NSEASONS=.;
        
      /************************************************
       compute _LOCAL_ZERO_THRESHOLD
      ************************************************/
      array _absolute_demand[1]/NOSYMBOLS; call dynamic_array(_absolute_demand, _TOT_NOBS); 
      array _demand[1]/NOSYMBOLS; call dynamic_array(_demand, _TOT_NOBS); 
      array _demand_all[1]/NOSYMBOLS; call dynamic_array(_demand_all, _TOT_NOBS+0); 
      array _idVar[1]/NOSYMBOLS; call dynamic_array(_idVar, _TOT_NOBS); 
      do i=1 to dim(_demand_all); _demand_all[i]=.; end;
      do t=1 to _TOT_NOBS;
         if TOTAL_ADJ_SALES_AMT[t] ne . then _absolute_demand[t]=abs(TOTAL_ADJ_SALES_AMT[t]);
         else _absolute_demand[t] = .;
         _demand[t]=TOTAL_ADJ_SALES_AMT[t];
         _demand_all[t]=TOTAL_ADJ_SALES_AMT[t];
         _idVar[t]=EOW_DATE[t];
      end;
      _LOCAL_ZERO_THRESHOLD = 0;

      if 0.005 ne 0 then do;
          call ci_compute_order_stats(_absolute_demand, _ABS_DEMAND_MIN, _ABS_DEMAND_MEDIAN, 
_ABS_DEMAND_MAX);
          if _ABS_DEMAND_MAX ne . then _LOCAL_ZERO_THRESHOLD=_ABS_DEMAND_MAX*0.005;
          else _LOCAL_ZERO_THRESHOLD=0;
      end;
      else do;
          _LOCAL_ZERO_THRESHOLD = 0;
      end;   
    
   
      /************************************************
        initialize array values
      ************************************************/
      do i=1 to dim(_season_code); _season_code[i]=.; end;
      do i=1 to dim(_seg_index); _seg_index[i]=.; end;
      do i=1 to dim(_seg_value); _seg_value[i]=.; end;
      do i=1 to dim(_active_demand); _active_demand[i]=.; end;
      do i=1 to dim(_demand_cycle_len); _demand_cycle_len[i]=.; end;
      do i=1 to dim(_period_start); _period_start[i]=.; end;
      do i=1 to dim(_period_end); _period_end[i]=.; end;
      do i=1 to dim(_event_date); _event_date[i]=.; end;
66                                      The SAS System              14:29 Monday, April 9, 2018

      do i=1 to dim(_before_dist); _before_dist[i]=.; end;
      do i=1 to dim(_after_dist); _after_dist[i]=.; end;
      do i=1 to dim(_season_index); _season_index[i]=.; end;
      do i=1 to dim(_season_flag); _season_flag[i]=.; end;
      do i=1 to dim(_out_fcst); _out_fcst[i]=.; end;
      do i=1 to dim(_eva_score); _eva_score[i]=.; end;
      
      /************************************************
        demand series approximation
      ************************************************/   
      rc = TSA_SEGMENTATION(_demand,"MEAN", "ABSOLUTE", 2, _TOT_NOBS-1, , , _seg_index, 
_seg_value);
      
      /************************************************
        compute statistics related to NOBS
      ************************************************/
      _LEADING_ZERO_LEN = dc_lead_zero_length(_seg_value, _LOCAL_ZERO_THRESHOLD);
      _TRAILING_ZERO_LEN = dc_trail_zero_length(_seg_value, _LOCAL_ZERO_THRESHOLD);
      if dim(_seg_value) > _TOT_NOBS then _TRAILING_ZERO_LEN=_TRAILING_ZERO_LEN-0;
      _TRIM_NOBS = _TOT_NOBS-_LEADING_ZERO_LEN-_TRAILING_ZERO_LEN;
      if _TRIM_NOBS<0 then _TRIM_NOBS=0;
      
      /************************************************
       identify components
      ************************************************/
      array _nonzero_demand[1]/NOSYMBOLS; call dynamic_array(_nonzero_demand, _TOT_NOBS); 
      array _demand_interval[1]/NOSYMBOLS; call dynamic_array(_demand_interval, _TOT_NOBS); 
      array _active_period_len[1]/NOSYMBOLS; call dynamic_array(_active_period_len, 
_TOT_NOBS); 
      array _gap_len[1]/NOSYMBOLS; call dynamic_array(_gap_len, _TOT_NOBS); 
      array _active_demand_trim[1]/NOSYMBOLS; call dynamic_array(_active_demand_trim, 
_TOT_NOBS); 
      array _seg_value_trim[1]/NOSYMBOLS; call dynamic_array(_seg_value_trim, _TOT_NOBS); 
      do i=1 to _TOT_NOBS; _seg_value_trim[i]=_seg_value[i]; end;

      call dc_identify_components(_seg_value_trim, _TRIM_NOBS, _LEADING_ZERO_LEN, 
_TRAILING_ZERO_LEN, _LOCAL_ZERO_THRESHOLD, 13,
                                   _nonzero_demand, _active_demand_trim, _demand_interval, 
_active_period_len, _demand_cycle_len, _gap_len,
                                   _NONZERO_DEMAND_COUNT, _DEMAND_COUNT, _DEMAND_INT_COUNT, 
_DEMAND_PERIOD_LEN_COUNT, _DEMAND_CYC_LEN_COUNT, 
                                   _GAP_INT_LEN_COUNT, _CURRENT_CYC_INDEX);  
      do i=1 to _TOT_NOBS; _active_demand[i]=_active_demand_trim[i]; end;
      call ci_find_active_period_range(_active_demand_trim, 0, 0, _period_start, _period_end, 
periodCount, tmp_rc);

      /************************************************
       check if the series is STS or not
       if eventIdentifyFlag is on, identify STS_TYPE
      ************************************************/
67                                      The SAS System              14:29 Monday, April 9, 2018

      if periodCount>0 and _DEMAND_CYC_LEN_COUNT>0 then do;
          do i=1 to dim(_demand_cycle_len);
            _demand_cycle_len[i]=.;
          end;
          _DEMAND_CYC_LEN_COUNT=periodCount;
          do i=1 to periodCount;
            _demand_cycle_len[i]=_period_end[i]-_period_start[i]+1;
          end;
          call dc_compute_basic_stats(_demand_cycle_len, _DEMAND_CYC_LEN_COUNT, 
_DEMAND_CYC_LEN_MEAN, _DEMAND_CYC_LEN_STDEV, _DEMAND_CYC_LEN_MIN, 
                                      _DEMAND_CYC_LEN_MEDIAN, _DEMAND_CYC_LEN_MAX);
        if _DEMAND_CYC_LEN_MAX<=39 and _CURRENT_CYC_INDEX-_TRAILING_ZERO_LEN<=39 then do;
          if 1 eq 0 then STS_TYPE = 1; /*seasonal*/
        end;
        else STS_TYPE = 0; /*NON-STS*/
      end;
      else STS_TYPE = 0; /*NON-STS*/
     
      if 1 ne 0 and STS_TYPE ne 0 then do;
        if _DEMAND_CYC_LEN_MEAN>9 then STS_TYPE = 1; /*seasonal*/
        else do;
          call ci_find_active_event(_active_demand_trim, _idVar, "_ciTmp.ciIdEventFile", 28, 
"WEEK", 0, EVENT_INDEX, tmp_rc);
          if EVENT_INDEX eq . then STS_TYPE=1; /*seasonal*/
          else STS_TYPE=2; /*event*/
        end;
      end;

      /************************************************
       Generate information for STS series
      ************************************************/      
      array _season_code_trim[1]/NOSYMBOLS; call dynamic_array(_season_code_trim, _TOT_NOBS);
      do i=1 to _TOT_NOBS; _season_code_trim[i]=.; end;
      
      if STS_TYPE=1 then do; /*season*/
        /************************************************
         Generate information for season type
        ************************************************/
    
      
        do i=1 to _TOT_NOBS+0;
          _season_index[i]=_SEASON_[i];
        end; 
      
         
        array periodRange[1]/NOSYMBOLS; call dynamic_array(periodRange, periodCount); 
        do t=1 to periodCount;
          periodRange[t]=_period_end[t]-_period_start[t]+1; 
        end;
        call ci_compute_order_stats(periodRange, _SEASON_LENGTH_MIN, _SEASON_LENGTH_MEDIAN, 
68                                      The SAS System              14:29 Monday, April 9, 2018

_SEASON_LENGTH_MAX);
        
        array allPeriodStart[1]/NOSYMBOLS; call dynamic_array(allPeriodStart, periodCount+2); 
        array allPeriodEnd[1]/NOSYMBOLS; call dynamic_array(allPeriodEnd, periodCount+2);
        call ci_find_active_period_range(_active_demand_trim, 1, 1, allPeriodStart, 
allPeriodEnd, allPeriodCount, tmp_rc);
        array inPeriodStart[1]/NOSYMBOLS; call dynamic_array(inPeriodStart, periodCount+1); 
        array inPeriodEnd[1]/NOSYMBOLS; call dynamic_array(inPeriodEnd, periodCount+1);
        
        bestSL = .; bestSS = .; 
        _BEST_SCORE=.;
        do sl=_SEASON_LENGTH_MIN to _SEASON_LENGTH_MAX;
          ssIndex=1;
          do t=1 to allPeriodCount;
            options = ci_season_compute_option_count(allPeriodStart, allPeriodEnd, 
allPeriodCount, _TOT_NOBS, sl, t);
            ssIndex=ssIndex*options;
          end;
          do ss=1 to ssIndex;
            call ci_find_season_series_seasons(allPeriodStart, allPeriodEnd, allPeriodCount, 
_TOT_NOBS, sl, ss,
                                               _season_code_trim, tmp_rc);
            if tmp_rc eq 0 then do;
              _EVA_COUNT=_EVA_COUNT+1;

              call ci_find_inseason_periods_by_code(_season_code_trim, 0, 1,inPeriodStart, 
inPeriodEnd, inPeriodCount);
              seasonStart=ci_find_season_start_index(inPeriodStart, inPeriodCount, 
_season_index, "MEAN");
              call ci_season_find_trim_info(_idVar, _season_code_trim, _season_index, 
_TOT_NOBS, "WEEK", 52, seasonStart, 
                                            leadLen, trailLen, expectTrailLen, rc);
                       
              call ci_generate_forecast_one(_demand, _season_code_trim, _TOT_NOBS, leadLen, 
trailLen, expectTrailLen, sl, 
                                "MEAN", "ACCUMULATE", "TOTAL", "AVG", "MIXED", 
                                "MSE", "_ciTmp.TmpModRepCopy", "_ciTmp.TmpDiagEst", 
"_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                                _out_fcst, outsize, rc);
                                
              call ci_compute_forecast_measure(_demand, _out_fcst, _TOT_NOBS, "MSE", score, 
scoreCount);  
              _eva_score[_EVA_COUNT]=score;                
              if _BEST_SCORE eq . then do;
                _BEST_SCORE=score;
                bestSL = sl; bestSS = ss; 
              end; 
              else if _BEST_SCORE>score then do;
                _BEST_SCORE=score;
                bestSL = sl; bestSS = ss; 
69                                      The SAS System              14:29 Monday, April 9, 2018

              end;           
            end;/*if tmp_rc eq 0 then do;*/
          end;/*do ss=1 to ssIndex;*/
        end;/*do sl=_SEASON_LENGTH_MIN to _SEASON_LENGTH_MAX;*/
        
        SEASON_LENGTH=bestSL;
        call ci_find_season_series_seasons(allPeriodStart, allPeriodEnd, allPeriodCount, 
_TOT_NOBS, bestSL, bestSS,
                                           _season_code_trim, rc); 
        call ci_find_inseason_periods_by_code(_season_code_trim, 0, 1,inPeriodStart, 
inPeriodEnd, inPeriodCount);
        SEASON_START=ci_find_season_start_index(inPeriodStart, inPeriodCount, _season_index, 
"MEAN");                                                                   
        call ci_season_find_trim_info(_idVar, _season_code_trim, _season_index, _TOT_NOBS, 
"WEEK", 52, SEASON_START, 
                                      leadLen, trailLen, expectTrailLen, rc);
        do i=1 to _TOT_NOBS; _season_code[i]=_season_code_trim[i];end;
        if 0>0 then do;
          flag=0;
          if _season_code[_TOT_NOBS]>0 then flag=1;
          do i=_TOT_NOBS+1 to _TOT_NOBS+0;
            if flag=1 then do;
              if _season_code[i-1]<SEASON_LENGTH then _season_code[i]=_season_code[i-1]+1;
              else do;
                flag=0;
                _season_code[i]=0;
              end;
            end;
            else do;
              if _season_index[i] eq SEASON_START then do;
                if i<_TOT_NOBS+0 then do;
                  if _season_index[i] eq _season_index[i+1] then _season_code[i]=0;
                  else do;
                    flag=1;
                    _season_code[i]=1;
                  end;
                end; 
                else do;
                  flag=1;
                  _season_code[i]=1;
                end;        
              end;
              else _season_code[i]=0;
            end;
          end;
          
        end;
                                              
      
          call ci_generate_forecast_one(_demand, _season_code_trim, _TOT_NOBS, leadLen, 
70                                      The SAS System              14:29 Monday, April 9, 2018

trailLen, expectTrailLen, bestSL, 
                            "MEAN", "ACCUMULATE", "TOTAL", "AVG", "MIXED", 
                            "MSE", "_ciTmp.TmpModRepCopy", "_ciTmp.TmpDiagEst", 
"_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                            _out_fcst, outsize, rc);
      
        
          call ci_find_inseason_periods_by_code(_season_code, 0, 1,inPeriodStart, inPeriodEnd, 
inPeriodCount);
          seasonStart=ci_find_season_start_index(inPeriodStart, inPeriodCount, _season_index, 
"MEAN");
          call ci_season_find_trim_info(EOW_DATE, _season_code, _season_index, _TOT_NOBS+0, 
"WEEK", 52, seasonStart, 
                                        leadLen, trailLen, expectTrailLen, rc);
  
          call ci_generate_forecast_one(_demand_all, _season_code, _TOT_NOBS+0, leadLen, 
trailLen, expectTrailLen, bestSL, 
                            "MEAN", "ACCUMULATE", "TOTAL", "ALL", "MIXED", 
                            "MSE", "_ciTmp.TmpModRepCopy", "_ciTmp.TmpDiagEst", 
"_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                            _ci_fcst, outsize, rc);
      
        
      end;
      else if STS_TYPE=2 then do;    
        /************************************************
         Generate information for event type
        ************************************************/  
        call ci_get_event_date("_ciTmp.ciIdEventFile", 28, EVENT_INDEX, _event_date, 
EVENT_COUNT, tmp_rc);        
        call ci_compute_event_distance(_period_start, _period_end, periodCount, _idVar, 
demandSize, 
                                       _event_date, EVENT_COUNT, "WEEK", 0, EVENT_INDEX,
                                       _before_dist, _after_dist, tmp_rc);  
        call dc_compute_basic_stats(_before_dist, _BEFORE_DIST_COUNT, _BEFORE_DIST_MEAN, 
_BEFORE_DIST_STDEV, _BEFORE_DIST_MIN, 
                                    _BEFORE_DIST_MEDIAN, _BEFORE_DIST_MAX);              
        call dc_compute_basic_stats(_after_dist, _AFTER_DIST_COUNT, _AFTER_DIST_MEAN, 
_AFTER_DIST_STDEV, _AFTER_DIST_MIN, 
                                    _AFTER_DIST_MEDIAN, _AFTER_DIST_MAX); 
        bestBD=.; bestAD=.;
        _BEST_SCORE=.;
        
        do bd=_BEFORE_DIST_MIN to _BEFORE_DIST_MAX;
          do ad=_AFTER_DIST_MIN to _AFTER_DIST_MAX;
            valid=1;
            if bd<0 and (ad<=0 or -bd>ad) then valid=0;
            if bd=0 and ad<0 then valid=0;
            if ad<0 and (bd<=0 or bd<-ad) then valid=0;
            if ad=0 and bd<0 then valid=0;
71                                      The SAS System              14:29 Monday, April 9, 2018

            if valid = 1 then do;
              _EVA_COUNT=_EVA_COUNT+1;
              call ci_find_event_series_seasons(_idVar, _event_date, EVENT_COUNT, "WEEK", bd, 
ad, _season_code_trim, inLen, tmp_rc); 

              call ci_event_find_trim_info(_idVar, _season_code_trim, _event_date, _TOT_NOBS, 
EVENT_COUNT, "WEEK", bd, 
                                           leadLen, trailLen, expectTrailLen, rc);
              call ci_generate_forecast_one(_demand, _season_code_trim, _TOT_NOBS, leadLen, 
trailLen, expectTrailLen, inLen, 
                                            "MEAN", "ACCUMULATE", "TOTAL", "AVG", "MIXED", 
                                            "MSE", "_ciTmp.TmpModRepCopy", 
"_ciTmp.TmpDiagEst", "_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                                            _out_fcst, outsize, rc);
              
              call ci_compute_forecast_measure(_demand, _out_fcst, _TOT_NOBS, "MSE", score, 
scoreCount);
              _eva_score[_EVA_COUNT]=score;
              if _BEST_SCORE eq . then do;
                _BEST_SCORE=score;
                bestBD=bd; bestAD=ad;
              end;
              else if _BEST_SCORE>score then do;
                _BEST_SCORE=score;
                bestBD=bd; bestAD=ad;
              end;
            end;/*if valid = 1 then do;*/
          end;/*do ad=_AFTER_DIST_MIN to _AFTER_DIST_MAX;*/
        end;/*do bd=_BEFORE_DIST_MIN to _BEFORE_DIST_MAX;*/
        
        BEFORE_EVENT=bestBD; AFTER_EVENT=bestAD;
        call ci_find_event_series_seasons(EOW_DATE, _event_date, EVENT_COUNT,  "WEEK", bestBD, 
bestAD, _season_code, inLen, tmp_rc);  
      
          call ci_find_event_series_seasons(_idVar, _event_date, EVENT_COUNT,  "WEEK", bestBD, 
bestAD, _season_code_trim, inLen, tmp_rc);  
          call ci_event_find_trim_info(_idVar, _season_code_trim, _event_date, _TOT_NOBS, 
EVENT_COUNT, "WEEK", bestBD, 
                                       leadLen, trailLen, expectTrailLen, rc);
          call ci_generate_forecast_one(_demand, _season_code_trim, _TOT_NOBS, leadLen, 
trailLen, expectTrailLen, inLen, 
                                        "MEAN", "ACCUMULATE", "TOTAL", "AVG", "MIXED",
                                        "MSE", "_ciTmp.TmpModRepCopy", "_ciTmp.TmpDiagEst", 
"_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                                        _out_fcst, outsize, rc);        
      

          call ci_event_find_trim_info(EOW_DATE, _season_code, _event_date, _TOT_NOBS+0, 
EVENT_COUNT, "WEEK", bestBD, 
                                       leadLen, trailLen, expectTrailLen, rc);
72                                      The SAS System              14:29 Monday, April 9, 2018

          call ci_generate_forecast_one(_demand_all, _season_code, _TOT_NOBS+0, leadLen, 
trailLen, expectTrailLen, inLen, 
                                        "MEAN", "ACCUMULATE", "TOTAL", "ALL", "MIXED",
                                        "MSE", "_ciTmp.TmpModRepCopy", "_ciTmp.TmpDiagEst", 
"_ciTmp.TmpInDataSet", "_ciTmp.TmpOutDataSet",
                                        _ci_fcst, outsize, rc);
      
      end;
      
        do i=1 to _TOT_NOBS+0;
          if _season_code[i]>0 then _season_flag[i]=1;
          else _season_flag[i]=0;
        end;
      
   
    run;
    
MPRINT(DCC_CLASS_FCMP_FNC):   proc fcmp ENCRYPT HIDE outlib=_ciTmp.timefnc.funcs;
MPRINT(DCC_CLASS_FCMP_FNC):   function dc_lead_zero_length(timedata[*], zero_demand_threshold);
MPRINT(DCC_CLASS_FCMP_FNC):   size = dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   lead =0;
MPRINT(DCC_CLASS_FCMP_FNC):   if size>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if zero_demand_threshold ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to size;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] ne . and (timedata[i]>zero_demand_threshold or (zero_demand_threshold>=0 and timedata[i]<-zero_demand_threshold)) then do;
MPRINT(DCC_CLASS_FCMP_FNC):   lead = i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   return (lead);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to size;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   lead = i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   return (lead);
36                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   lead=size;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   return (lead);
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   function dc_trail_zero_length(timedata[*], zero_demand_threshold);
MPRINT(DCC_CLASS_FCMP_FNC):   size = dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   trail =0;
MPRINT(DCC_CLASS_FCMP_FNC):   if size>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if zero_demand_threshold ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to size;
MPRINT(DCC_CLASS_FCMP_FNC):   j=size-i+1;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[j] ne . and (timedata[j]>zero_demand_threshold or (zero_demand_threshold>=0 and timedata[j]<-zero_demand_threshold)) then do;
MPRINT(DCC_CLASS_FCMP_FNC):   trail = i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   return (trail);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to size;
MPRINT(DCC_CLASS_FCMP_FNC):   j=size-i+1;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[j] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   trail = i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   return (trail);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   trail=size;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   return (trail);
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_compute_sum(timedata[*], sum, count);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs sum, count;
MPRINT(DCC_CLASS_FCMP_FNC):   sum = .;
MPRINT(DCC_CLASS_FCMP_FNC):   count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   length=dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   if length>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   sum=0;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to length;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   sum = sum + timedata[i];
MPRINT(DCC_CLASS_FCMP_FNC):   count = count+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if count=0 then sum=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_compute_mean(timedata[*], mean, count);
37                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   outargs mean, count;
MPRINT(DCC_CLASS_FCMP_FNC):   mean = .;
MPRINT(DCC_CLASS_FCMP_FNC):   count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   length=dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   if length>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   call dc_compute_sum(timedata, sum, count);
MPRINT(DCC_CLASS_FCMP_FNC):   if count>0 and sum ne . then mean = sum / count;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   function dc_compute_stdev(timedata[*], mean, count);
MPRINT(DCC_CLASS_FCMP_FNC):   stdev = .;
MPRINT(DCC_CLASS_FCMP_FNC):   length=dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   if length>0 and count>1 and mean^=. then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp = 0;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to length;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] ^= . then temp = temp + (timedata[i]-mean)**2;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   stdev = sqrt (temp / (count-1));
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   return (stdev);
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_compute_order_stats(timedata[*], min, median, max);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs min, median, max;
MPRINT(DCC_CLASS_FCMP_FNC):   array order[1]/NOSYMBOLS;
MPRINT(DCC_CLASS_FCMP_FNC):   min = .;
MPRINT(DCC_CLASS_FCMP_FNC):   median = .;
MPRINT(DCC_CLASS_FCMP_FNC):   max = .;
MPRINT(DCC_CLASS_FCMP_FNC):   length=dim(timedata);
MPRINT(DCC_CLASS_FCMP_FNC):   if length>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(order, length);
MPRINT(DCC_CLASS_FCMP_FNC):   count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to length;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   count = count+1;
MPRINT(DCC_CLASS_FCMP_FNC):   order[count]=timedata[i];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if count>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if count=1 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   min = order[1];
MPRINT(DCC_CLASS_FCMP_FNC):   median = order[1];
MPRINT(DCC_CLASS_FCMP_FNC):   max = order[1];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to count-1;
MPRINT(DCC_CLASS_FCMP_FNC):   do j=1 to count-1;
MPRINT(DCC_CLASS_FCMP_FNC):   if order[j]>order[j+1] then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp = order[j];
MPRINT(DCC_CLASS_FCMP_FNC):   order[j]=order[j+1];
MPRINT(DCC_CLASS_FCMP_FNC):   order[j+1]=temp;
38                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   min=order[1];
MPRINT(DCC_CLASS_FCMP_FNC):   max=order[count];
MPRINT(DCC_CLASS_FCMP_FNC):   index=floor(count/2);
MPRINT(DCC_CLASS_FCMP_FNC):   if index*2<count then median = order[index+1];
MPRINT(DCC_CLASS_FCMP_FNC):   else median = (order[index]+order[index+1])/2;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_compute_basic_stats(timedata[*], count, mean, stdev, min, median, max);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs count, mean, stdev, min, median, max;
MPRINT(DCC_CLASS_FCMP_FNC):   count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   mean=.;
MPRINT(DCC_CLASS_FCMP_FNC):   stdev=.;
MPRINT(DCC_CLASS_FCMP_FNC):   min=.;
MPRINT(DCC_CLASS_FCMP_FNC):   median=.;
MPRINT(DCC_CLASS_FCMP_FNC):   max=.;
MPRINT(DCC_CLASS_FCMP_FNC):   call dc_compute_mean(timedata, mean, count);
MPRINT(DCC_CLASS_FCMP_FNC):   stdev = dc_compute_stdev(timedata, mean, count);
MPRINT(DCC_CLASS_FCMP_FNC):   call dc_compute_order_stats(timedata, min, median, max);
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_identify_components(timedata[*], trim_nobs, lead_zero_len, trail_zero_len, zero_demand_threshold, gap_period_threshold, nonzero_demand[*], active_demand[*], demand_interval[*], active_period_len[*], 
demand_cycle_len[*], gap_len[*], nonzero_demand_count, active_demand_count, demand_interval_count, active_period_count, demand_cycle_count, gap_count, current_cycle_index);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs nonzero_demand, active_demand, demand_interval, active_period_len, demand_cycle_len, gap_len, nonzero_demand_count, active_demand_count, demand_interval_count, active_period_count, demand_cycle_count, gap_count, 
current_cycle_index;
MPRINT(DCC_CLASS_FCMP_FNC):   nonzero_demand_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   active_demand_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_interval_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   active_period_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_cycle_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   gap_count=0;
MPRINT(DCC_CLASS_FCMP_FNC):   current_cycle_index=0;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(nonzero_demand);
MPRINT(DCC_CLASS_FCMP_FNC):   nonzero_demand[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(active_demand);
MPRINT(DCC_CLASS_FCMP_FNC):   active_demand[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(demand_interval);
MPRINT(DCC_CLASS_FCMP_FNC):   demand_interval[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(active_period_len);
MPRINT(DCC_CLASS_FCMP_FNC):   active_period_len[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(demand_cycle_len);
MPRINT(DCC_CLASS_FCMP_FNC):   demand_cycle_len[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
39                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(gap_len);
MPRINT(DCC_CLASS_FCMP_FNC):   gap_len[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if trim_nobs>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   array zero_st[1]/NOSYMBOLS;
MPRINT(DCC_CLASS_FCMP_FNC):   array zero_end[1]/NOSYMBOLS;
MPRINT(DCC_CLASS_FCMP_FNC):   array period_st[1]/NOSYMBOLS;
MPRINT(DCC_CLASS_FCMP_FNC):   array period_end[1]/NOSYMBOLS;
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(zero_st, trim_nobs);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(zero_end, trim_nobs);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(period_st, trim_nobs);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(period_end, trim_nobs);
MPRINT(DCC_CLASS_FCMP_FNC):   st=0;
MPRINT(DCC_CLASS_FCMP_FNC):   zl=0;
MPRINT(DCC_CLASS_FCMP_FNC):   if zero_demand_threshold ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=lead_zero_len+1 to lead_zero_len+trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] eq . or (zero_demand_threshold<0 and timedata[i]<= zero_demand_threshold) or (zero_demand_threshold>=0 and timedata[i]<= zero_demand_threshold and timedata[i]>= -zero_demand_threshold) then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if st=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   st = 1;
MPRINT(DCC_CLASS_FCMP_FNC):   zl = zl+1;
MPRINT(DCC_CLASS_FCMP_FNC):   zero_st[zl]=i;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   if st=1 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   zero_end[zl]=i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   st=0;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=lead_zero_len+1 to lead_zero_len+trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[i] eq . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if st=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   st = 1;
MPRINT(DCC_CLASS_FCMP_FNC):   zl = zl+1;
MPRINT(DCC_CLASS_FCMP_FNC):   zero_st[zl]=i;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if timedata[i] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if st=1 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   zero_end[zl]=i-1;
MPRINT(DCC_CLASS_FCMP_FNC):   st=0;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   period=1;
MPRINT(DCC_CLASS_FCMP_FNC):   period_st[period]=1+lead_zero_len;
40                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   if zl>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to zl;
MPRINT(DCC_CLASS_FCMP_FNC):   zerolength=zero_end[i]-zero_st[i]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   if zerolength>gap_period_threshold then do;
MPRINT(DCC_CLASS_FCMP_FNC):   gap_count=gap_count+1;
MPRINT(DCC_CLASS_FCMP_FNC):   gap_len[zero_end[i]]=zerolength;
MPRINT(DCC_CLASS_FCMP_FNC):   period_end[period]=zero_st[i]-1;
MPRINT(DCC_CLASS_FCMP_FNC):   period=period+1;
MPRINT(DCC_CLASS_FCMP_FNC):   period_st[period]=zero_end[i]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   period_end[period]=trim_nobs+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to period;
MPRINT(DCC_CLASS_FCMP_FNC):   last_nz=period_st[i];
MPRINT(DCC_CLASS_FCMP_FNC):   do j=period_st[i] to period_end[i];
MPRINT(DCC_CLASS_FCMP_FNC):   if (zero_demand_threshold ne . and timedata[j] ne . and (timedata[j]> zero_demand_threshold) or (zero_demand_threshold>=0 and timedata[j]<-zero_demand_threshold)) or (zero_demand_threshold eq . and timedata[j] ne .) then do;
MPRINT(DCC_CLASS_FCMP_FNC):   nonzero_demand_count = nonzero_demand_count +1;
MPRINT(DCC_CLASS_FCMP_FNC):   nonzero_demand[j]=timedata[j];
MPRINT(DCC_CLASS_FCMP_FNC):   if j>period_st[i] then do;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_interval_count = demand_interval_count+1;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_interval[j]=j-last_nz;
MPRINT(DCC_CLASS_FCMP_FNC):   last_nz=j;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   active_demand_count = active_demand_count +1;
MPRINT(DCC_CLASS_FCMP_FNC):   active_demand[j]=timedata[j];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   active_period_count = active_period_count+1;
MPRINT(DCC_CLASS_FCMP_FNC):   active_period_len[period_end[i]] = period_end[i]-period_st[i]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   if i<period then demand_cycle_len[period_end[i]] = active_period_len[period_end[i]];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if trail_zero_len<=gap_period_threshold then do;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_cycle_count = active_period_count -1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_cycle_count=active_period_count;
MPRINT(DCC_CLASS_FCMP_FNC):   demand_cycle_len[period_end[period]] = active_period_len[period_end[period]];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   current_cycle_index = trim_nobs+lead_zero_len+trail_zero_len-period_st[period]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_intermittency_test(demand_interval[*], measure $, threshold, intermit_flg, rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs intermit_flg, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   intermit_flg=.;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=1;
MPRINT(DCC_CLASS_FCMP_FNC):   length=dim(demand_interval);
MPRINT(DCC_CLASS_FCMP_FNC):   if length>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   compare=.;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=0;
41                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   if measure="MEAN" then do;
MPRINT(DCC_CLASS_FCMP_FNC):   call dc_compute_mean(demand_interval, compare, count);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if measure="MEDIAN" then do;
MPRINT(DCC_CLASS_FCMP_FNC):   call dc_compute_order_stats(demand_interval, min, compare, max);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=10;
MPRINT(DCC_CLASS_FCMP_FNC):   if rc=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   if compare=. then do;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=2;
MPRINT(DCC_CLASS_FCMP_FNC):   intermit_flg=0;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   if compare<threshold then intermit_flg=0;
MPRINT(DCC_CLASS_FCMP_FNC):   else intermit_flg=1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_derive_deactive_status_1(trailing_zero_length, deactive_threshold, deactive, rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs deactive, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=0;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=0;
MPRINT(DCC_CLASS_FCMP_FNC):   if trailing_zero_length>deactive_threshold then do;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=1;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_derive_deactive_status_2(trim_nobs, trailing_zero_length, calendar_cyc_period, deactive_buffer_period, prelim_by_n, gap_int_len_max, demand_int_max, cyc_len_min, deactive, rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs deactive, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=0;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=2;
MPRINT(DCC_CLASS_FCMP_FNC):   if trim_nobs+trailing_zero_length>calendar_cyc_period+deactive_buffer_period then do;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=3;
MPRINT(DCC_CLASS_FCMP_FNC):   if trailing_zero_length>calendar_cyc_period+deactive_buffer_period then do;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=1;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=4;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if gap_int_len_max ne . and trailing_zero_length>gap_int_len_max+deactive_buffer_period then do;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=1;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=5;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if gap_int_len_max eq . and prelim_by_n=11 and trailing_zero_length>demand_int_max+deactive_buffer_period then do;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=1;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=6;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if prelim_by_n=12 and cyc_len_min+trailing_zero_length>calendar_cyc_period+deactive_buffer_period then do;
MPRINT(DCC_CLASS_FCMP_FNC):   deactive=1;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=7;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
42                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_internal_accumulate_series(timedata[*], timeid[*], trim_nobs, lead_zero_len, accum_interval $, setmissing $, indataset $, outdataset $, accumdata[*], accumid[*], accumlen, rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs accumdata, accumid, accumlen, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=1;
MPRINT(DCC_CLASS_FCMP_FNC):   accumlen=0;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(accumdata);
MPRINT(DCC_CLASS_FCMP_FNC):   accumdata[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(accumid);
MPRINT(DCC_CLASS_FCMP_FNC):   accumid[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if trim_nobs>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   array series[1,1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   array tmp[1, 1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc=5;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=5;
MPRINT(DCC_CLASS_FCMP_FNC):   length = trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(series, length, 2);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(tmp, length, 2);
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to length;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   series[t,1]=timeid[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   series[t,2]=timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc = write_array(indataset, series, 'time_id', 'demand');
MPRINT(DCC_CLASS_FCMP_FNC):   if temp_rc=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc = run_macro('dcc_class_internal_accum', indataset, outdataset, accum_interval, setmissing);
MPRINT(DCC_CLASS_FCMP_FNC):   if temp_rc=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc = read_array(outdataset, tmp, 'time_id', 'demand');
MPRINT(DCC_CLASS_FCMP_FNC):   if temp_rc=0 then rc=0;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=4;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=3;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=2;
MPRINT(DCC_CLASS_FCMP_FNC):   if rc=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   accumlen=DIM(tmp);
MPRINT(DCC_CLASS_FCMP_FNC):   do t = 1 to accumlen;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   accumid[tt]=tmp[t,1];
MPRINT(DCC_CLASS_FCMP_FNC):   accumdata[tt] = tmp[t,2];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_internal_seasonality_test(timedata[*], timeid[*], trim_nobs, lead_zero_len, lts_min_seasonal_test_len, lts_seasontest_siglevel, indataset $, outdataset $, test_season, test_interval $, season_flg, rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs season_flg, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   season_flg=.;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=1;
43                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   if trim_nobs>=lts_min_seasonal_test_len and trim_nobs>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc=4;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=4;
MPRINT(DCC_CLASS_FCMP_FNC):   array series[1,1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(series, trim_nobs, 2);
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   series[t,1]=timeid[t+lead_zero_len];
MPRINT(DCC_CLASS_FCMP_FNC):   series[t,2]=timedata[t+lead_zero_len];
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc = write_array(indataset, series, 'time_id', 'demand');
MPRINT(DCC_CLASS_FCMP_FNC):   if temp_rc=0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   temp_rc = run_macro('dcc_class_internal_season_test', indataset, outdataset, test_season, test_interval, lts_seasontest_siglevel, season_flg);
MPRINT(DCC_CLASS_FCMP_FNC):   if temp_rc=0 then rc=0;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=3;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else rc=2;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
MPRINT(DCC_CLASS_FCMP_FNC):   subroutine dc_generate_profile(timedata[*], timeid[*], trim_nobs, lead_zero_len, profile_type $, profile_size, profile[*], rc);
MPRINT(DCC_CLASS_FCMP_FNC):   outargs profile, rc;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=1;
MPRINT(DCC_CLASS_FCMP_FNC):   do i=1 to dim(profile);
MPRINT(DCC_CLASS_FCMP_FNC):   profile[i]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if trim_nobs>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=3;
MPRINT(DCC_CLASS_FCMP_FNC):   if profile_size>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=4;
MPRINT(DCC_CLASS_FCMP_FNC):   array total[1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   array count[1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   array avg[1] / nosymbols;
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(total, profile_size);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(count, profile_size);
MPRINT(DCC_CLASS_FCMP_FNC):   call dynamic_array(avg, profile_size);
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to profile_size;
MPRINT(DCC_CLASS_FCMP_FNC):   total[t]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   count[t]=0;
MPRINT(DCC_CLASS_FCMP_FNC):   avg[t]=.;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if profile_type='DOW' then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[tt] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   index=weekday(timeid[tt]);
MPRINT(DCC_CLASS_FCMP_FNC):   if total[index]=. then total[index]=timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   else total[index] = total[index]+timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   count[index]=count[index]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
44                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   else if profile_type='WOY' then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[tt] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   index=week(timeid[tt])+1;
MPRINT(DCC_CLASS_FCMP_FNC):   if total[index]=. then total[index]=timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   else total[index] = total[index]+timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   count[index]=count[index]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if profile_type='MOY' then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[tt] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   index=month(timeid[tt]);
MPRINT(DCC_CLASS_FCMP_FNC):   if total[index]=. then total[index]=timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   else total[index] = total[index]+timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   count[index]=count[index]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   else if profile_type='QOY' then do;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to trim_nobs;
MPRINT(DCC_CLASS_FCMP_FNC):   tt=t+lead_zero_len;
MPRINT(DCC_CLASS_FCMP_FNC):   if timedata[tt] ne . then do;
MPRINT(DCC_CLASS_FCMP_FNC):   index=qtr(timeid[tt]);
MPRINT(DCC_CLASS_FCMP_FNC):   if total[index]=. then total[index]=timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   else total[index] = total[index]+timedata[tt];
MPRINT(DCC_CLASS_FCMP_FNC):   count[index]=count[index]+1;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   sumavg=0;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to profile_size;
MPRINT(DCC_CLASS_FCMP_FNC):   if count[t]>0 then do;
MPRINT(DCC_CLASS_FCMP_FNC):   avg[t]=total[t]/count[t];
MPRINT(DCC_CLASS_FCMP_FNC):   sumavg = sumavg+abs(avg[t]);
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   if sumavg=0 then rc=2;
MPRINT(DCC_CLASS_FCMP_FNC):   else do;
MPRINT(DCC_CLASS_FCMP_FNC):   do t=1 to profile_size;
MPRINT(DCC_CLASS_FCMP_FNC):   if avg[t] ne . then profile[t]=avg[t]/sumavg;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   rc=0;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   end;
MPRINT(DCC_CLASS_FCMP_FNC):   endsub;
45                                                                                                                       The SAS System                                                                                              14:29 Monday, April 9, 2018

MPRINT(DCC_CLASS_FCMP_FNC):   run;
NOTE: Function dc_generate_profile saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_internal_seasonality_test saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_internal_accumulate_series saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_derive_deactive_status_2 saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_derive_deactive_status_1 saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_intermittency_test saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_identify_components saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_compute_basic_stats saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_compute_order_stats saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_compute_stdev saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_compute_mean saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_compute_sum saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_trail_zero_length saved to _ciTmp.timefnc.funcs.
NOTE: Function dc_lead_zero_length saved to _ciTmp.timefnc.funcs.
NOTE: PROCEDURE FCMP used (Total process time):
      real time           3.45 seconds
      cpu time            0.59 seconds
      

MPRINT(DCC_CLASS_FCMP_FNC):   quit;
NOTE: There were 194 observations read from the data set _CITMP.INDATAFILTERED.
NOTE: The data set _CITMP.INDATAFILTERED has 194 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.06 seconds
      cpu time            0.03 seconds
      

ERROR: Cannot find a library containing subroutine TSA_SEGMENTATION.
NOTE: There are 194 time periods between START=Saturday and END=Saturday.
NOTE: Number of BY groups processed: 0
NOTE: Number of series processed: 0
NOTE: The data set _CITMP.CIIDOUTAGG has 0 observations and 0 variables.
NOTE: The data set _CITMP.CIIDOUTSCALAR has 0 observations and 0 variables.
NOTE: The data set _CITMP.CIIDOUTARRAY has 0 observations and 0 variables.
NOTE: PROCEDURE TIMEDATA used (Total process time):
      real time           13.22 seconds
      cpu time            1.64 seconds
      

...Custom Interval Identification Component has finished.
...Starting Forecasting Component...
ERROR: [CUSTOM_INTERVAL_FORECAST component] The time ID variable EOW_DATE does not exist in data _ciTmp.ciIDOutArray
ERROR: ...t\..\..\../fswbsrvr/misc/source/lua/fscb\common\util.lua:26: [CUSTOM_INTERVAL_FORECAST component] The time ID variable EOW_DATE does not exist in data _ciTmp.ciIDOutArray
stack traceback:
	[C]: in function 'error'
	...t\..\..\../fswbsrvr/misc/source/lua/fscb\common\util.lua:26: in function 'my_assert'
	...srvr/misc/source/lua/fscb\customInterval\ci_forecast.lua:28: in function 'validate_ci_args'
	...srvr/misc/source/lua/fscb\customInterval\ci_forecast.lua:273: in function 'custom_interval_forecast'
	.../fswbsrvr/misc/source/lua/fscb\customInterval\ci_run.lua:734: in function 'ci_forecast_run'
	SUBMIT block:17: in main chunk
ERROR: There was an error submitting the provided code
NOTE: The SAS System stopped processing this step because of errors.
NOTE: SAS set option OBS=0 and will continue to check statements. 
      This might cause NOTE: No observations in data set.
NOTE: PROCEDURE LUA used (Total process time):
      real time           32.20 seconds
      cpu time            4.40 seconds
      
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTMODEL1.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTFOR1.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   proc lua restart;
MPRINT(RUN_UNIT_TEST):   submit;
MPRINT(RUN_UNIT_TEST):   run;

73                                      The SAS System              14:29 Monday, April 9, 2018

NOTE: PROCEDURE LUA used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTMODEL2.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTFOR2.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   proc lua restart;
MPRINT(RUN_UNIT_TEST):   submit;
MPRINT(RUN_UNIT_TEST):   run;

NOTE: PROCEDURE LUA used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTMODEL3.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTFOR3.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
74                                      The SAS System              14:29 Monday, April 9, 2018

MPRINT(RUN_UNIT_TEST):   proc sql noprint;
NOTE: PROC SQL set option NOEXEC and will continue to check the syntax of statements.
MPRINT(RUN_UNIT_TEST):   create table outFor3_merge as select a.*, b.TOTAL_ADJ_SALES_AMT from 
outFor3 as a, test.Fall_winter_avg as b where a.EOW_DATE=b.EOW_DATE order by EOW_DATE;
NOTE: Statement not executed due to NOEXEC option.
NOTE: PROC SQL statements are executed immediately; The RUN statement has no effect.
MPRINT(RUN_UNIT_TEST):   run;
MPRINT(RUN_UNIT_TEST):   quit;
NOTE: The SAS System stopped processing this step because of errors.
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.06 seconds
      cpu time            0.00 seconds
      
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   proc lua restart;
MPRINT(RUN_UNIT_TEST):   submit;
MPRINT(RUN_UNIT_TEST):   run;

NOTE: PROCEDURE LUA used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTMODEL4.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTFOR4.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   proc lua restart;
MPRINT(RUN_UNIT_TEST):   submit;
MPRINT(RUN_UNIT_TEST):   run;

75                                      The SAS System              14:29 Monday, April 9, 2018

NOTE: PROCEDURE LUA used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTMODEL5.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
ERROR: File WORK.OUTFOR5.DATA does not exist.
WARNING: The data set WORK._TMP may be incomplete.  When this step was stopped there were 0 
         observations and 0 variables.
WARNING: Data set WORK._TMP was not replaced because this step was stopped.
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(TST_LOG):   option lrecl = 256;
MPRINT(TST_LOG):   options nonotes nomprint nosymbolgen
MPRINT(TST_LOG):   NOSYMBOLGEN ;
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST_PUT):   data _null_;
MPRINT(RUN_UNIT_TEST_PUT):   file res mod;
MPRINT(RUN_UNIT_TEST_PUT):   put "ERROR: during while executing 
run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/custom_interval/run1.sas";
MPRINT(RUN_UNIT_TEST_PUT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

UNIT_TESTS: ERROR: during while executing 
run_unit_tests.bat\..\..\../fswbsrvr/unit_tests/custom_interval/run1.sas
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST_PUT):   data _null_;
MPRINT(RUN_UNIT_TEST_PUT):   file res mod;
MPRINT(RUN_UNIT_TEST_PUT):   put "RESULT=failed";
MPRINT(RUN_UNIT_TEST_PUT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

UNIT_TESTS: RESULT=failed
76                                      The SAS System              14:29 Monday, April 9, 2018

MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST_PUT):   filename res clear;
NOTE: Fileref RES has been deassigned.
MPRINT(RUN_UNIT_TEST):  ;
MPRINT(RUN_UNIT_TEST):   * echo result file to the log;
MPRINT(RUN_UNIT_TEST):   options nonotes nomprint nosymbolgen
----------------------------------------------------
----------------------------------------------------
MPRINT(RUN_UNIT_TEST):   NOSYMBOLGEN;

ERROR: Errors printed on pages 72,73,74,75.

NOTE: SAS Institute Inc., SAS Campus Drive, Cary, NC USA 27513-2414
NOTE: The SAS System used:
      real time           34.01 seconds
      cpu time            5.07 seconds
      
